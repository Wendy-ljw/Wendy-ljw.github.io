{"meta":{"title":"Wendy","subtitle":"","description":"","author":"Wendy","url":"https://wendy-ljw.github.io","root":"/"},"pages":[{"title":"朋友","date":"2022-11-15T12:46:38.231Z","updated":"2022-11-15T12:46:38.231Z","comments":true,"path":"PY.html","permalink":"https://wendy-ljw.github.io/PY.html","excerpt":"","text":"戳这可见文特的博客"},{"title":"文章归档","date":"2022-11-10T11:15:45.811Z","updated":"2022-11-10T11:15:45.811Z","comments":true,"path":"archive.html","permalink":"https://wendy-ljw.github.io/archive.html","excerpt":"","text":""},{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2022-11-10T11:04:24.717Z","comments":true,"path":"page/index.html","permalink":"https://wendy-ljw.github.io/page/index.html","excerpt":"","text":"This is a page test."},{"title":"关于","date":"2022-11-15T12:46:33.299Z","updated":"2022-11-15T12:46:33.299Z","comments":true,"path":"about.html","permalink":"https://wendy-ljw.github.io/about.html","excerpt":"","text":"今天我终于把我的博客搭建成功了"}],"posts":[{"title":"js高级-es6笔记(4)","slug":"js-es6-4","date":"2022-11-19T02:33:01.000Z","updated":"2022-11-24T13:47:23.037Z","comments":true,"path":"2022/11/19/js-es6-4/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/19/js-es6-4/","excerpt":"","text":"JavaScript 进阶 - 第4天一、深浅拷贝首先浅拷贝和深拷贝只针对像Object,Array这样的复杂对象，简单来说，浅拷贝只复制一层对象的属性，二深拷贝则复制了所有的层级。 1.1 浅拷贝 浅拷贝：拷贝的是地址 拷贝对象：Object.assgin() &#x2F; 展开运算符 {…obj} 拷贝数组：Array.prototype.concat() 或者 […arr] 123456789101112131415161718192021const obj = &#123; uname: &#x27;pink&#x27;, age: 18, family: &#123; baby: &#x27;小pink&#x27; &#125;&#125;// 浅拷贝1 const o = &#123; ...obj &#125;console.log(o)o.age = 20console.log(o)console.log(obj)// 2const o = &#123;&#125;Object.assign(o, obj)o.age = 20o.family.baby = &#x27;老pink&#x27;console.log(o)console.log(obj) 1.2 深拷贝 深拷贝：拷贝的是对象，不是地址 常见方法： 通过递归实现深拷贝 lodash&#x2F;cloneDeep 通过JSON.stringify()实现 1.2.1 通过递归实现深拷贝 递归函数：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数 简单理解：函数内部自己调用自己，这个函数就是递归函数 递归函数的作用和循环效果类似 由于递归很容易发生“栈溢出”错误，所以必须要加推出条件return 12345678910111213141516171819202122232425262728293031323334353637const obj = &#123; uname: &#x27;pink&#x27;, age: 18, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;], family: &#123; baby: &#x27;小pink&#x27; &#125;&#125;const o = &#123;&#125;// 拷贝函数function deepCopy(newObj, oldObj) &#123; debugger //打断点 for (let k in oldObj) &#123; // 处理数组的问题 一定先写数组 在写 对象 不能颠倒 if (oldObj[k] instanceof Array) &#123; newObj[k] = [] // newObj[k] 接收 [] hobby // oldObj[k] [&#x27;乒乓球&#x27;, &#x27;足球&#x27;] deepCopy(newObj[k], oldObj[k]) &#125; else if (oldObj[k] instanceof Object) &#123; newObj[k] = &#123;&#125; deepCopy(newObj[k], oldObj[k]) &#125; else &#123; // k 属性名 uname age oldObj[k] 属性值 18 // newObj[k] === o.uname 给新对象添加属性 newObj[k] = oldObj[k] &#125; &#125;&#125;deepCopy(o, obj) // 函数调用 两个参数 o 新对象 obj 旧对象console.log(o)o.age = 20o.hobby[0] = &#x27;篮球&#x27;o.family.baby = &#x27;老pink&#x27;console.log(obj)console.log([1, 23] instanceof Object)//true 1.2.2 js库loadash里面cloneDeep内部实现了深拷贝12345678910111213141516&lt;!-- 先引用 --&gt;&lt;script src=&quot;./lodash.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const obj = &#123; uname: &#x27;pink&#x27;, age: 18, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;], family: &#123; baby: &#x27;小pink&#x27; &#125; &#125; const o = _.cloneDeep(obj) console.log(o) o.family.baby = &#x27;老pink&#x27; console.log(obj)&lt;/script&gt; 1.2.3 利用JSON实现深拷贝1234567891011121314const obj = &#123; uname: &#x27;pink&#x27;, age: 18, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;], family: &#123; baby: &#x27;小pink&#x27; &#125;&#125;// 把对象转换为 JSON 字符串// console.log(JSON.stringify(obj))const o = JSON.parse(JSON.stringify(obj))console.log(o)o.family.baby = &#x27;123&#x27;console.log(obj) 对于字符串类型，浅拷贝是对值的复制，对于对象来说，浅拷贝是对对象地址的复制，并没有开辟新的栈，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会 改变，而深拷贝则是开辟新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。 二、异常处理 了解 JavaScript 中程序异常处理的方法，提升代码运行的健壮性。 2.1 throw异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行。 12345678910111213&lt;script&gt; function counter(x, y) &#123; if(!x || !y) &#123; // throw &#x27;参数不能为空!&#x27;; throw new Error(&#x27;参数不能为空!&#x27;) &#125; return x + y &#125; counter()&lt;/script&gt; 总结： throw 抛出异常信息，程序也会终止执行 throw 后面跟的是错误提示信息 Error 对象配合 throw 使用，能够设置更详细的错误信息 2.2 try … catch123456789101112131415161718192021&lt;script&gt; function foo() &#123; try &#123; // 查找 DOM 节点 const p = document.querySelector(&#x27;.p&#x27;) p.style.color = &#x27;red&#x27; &#125; catch (error) &#123; // try 代码段中执行有错误时，会执行 catch 代码段 // 查看错误信息 console.log(error.message) // 终止代码继续执行 return &#125; finally &#123; alert(&#x27;执行&#x27;) &#125; console.log(&#x27;如果出现错误，我的语句不会执行&#x27;) &#125; foo()&lt;/script&gt; 总结： try...catch 用于捕获错误信息 将预估可能发生错误的代码写在 try 代码段中 如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息 三、this 了解函数中 this 在不同场景下的默认值，知道动态指定函数 this 值的方法。 1.1 默认值this 是 JavaScript 最具“魅惑”的知识点，不同的应用场合 this 的取值可能会有意想不到的结果，在此我们对以往学习过的关于[this 默认的取值]情况进行归纳和总结。 普通函数普通函数的调用方式决定了 this 的值，即【谁调用 this 的值指向谁】，如下代码所示： 123456789101112131415161718192021222324252627282930313233343536&lt;button&gt;点击&lt;/button&gt;&lt;script&gt; // 普通函数： 谁调用我，this就指向谁 console.log(this) // window function fn() &#123; console.log(this) // window &#125; window.fn() window.setTimeout(function () &#123; console.log(this) // window &#125;, 1000) document.querySelector(&#x27;button&#x27;).addEventListener(&#x27;click&#x27;, function () &#123; console.log(this) // 指向 button &#125;) const obj = &#123; sayHi: function () &#123; console.log(this) // 指向 obj &#125; &#125; obj.sayHi() // 普通对象 const user = &#123; name: &#x27;小明&#x27;, walk: function () &#123; console.log(this) &#125; &#125; // 动态为 user 添加方法 user.sayHi = sayHi uesr.sayHello = sayHello // 函数调用方式，决定了 this 的值 user.sayHi() user.sayHello()&lt;/script&gt; 注： 普通函数没有明确调用者时 this 值为 window，严格模式下没有调用者时 this 的值为 undefined。 箭头函数箭头函数中的 this 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 this ！箭头函数中访问的 this 不过是箭头函数所在作用域的 this 变量。 箭头函数会默认帮我们绑定外层this的值，所以在箭头函数this的值和外层的this是一样的。 箭头函数中的this引用的就是最近作用域中的this 向外层作用域中，一层一层查找this，直到有this的定义 1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; console.log(this) // 此处为 window // 箭头函数 const sayHi = function() &#123; console.log(this) // 该箭头函数中的 this 为函数声明环境中 this 一致 &#125; // 普通对象 const user = &#123; name: &#x27;小明&#x27;, // 该箭头函数中的 this 为函数声明环境中 this 一致 walk: () =&gt; &#123; console.log(this) &#125;, sleep: function () &#123; let str = &#x27;hello&#x27; console.log(this) let fn = () =&gt; &#123; console.log(str) console.log(this) // 该箭头函数中的 this 与 sleep 中的 this 一致 &#125; // 调用箭头函数 fn(); &#125; &#125; // 动态添加方法 user.sayHi = sayHi // 函数调用 user.sayHi() user.sleep() user.walk()&lt;/script&gt; 在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此DOM事件回调函数不推荐使用箭头函数，如下代码所示： 123456789101112&lt;script&gt; // DOM 节点 const btn = document.querySelector(&#x27;.btn&#x27;) // 箭头函数 此时 this 指向了 window btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; console.log(this) &#125;) // 普通函数 此时 this 指向了 DOM 对象 btn.addEventListener(&#x27;click&#x27;, function () &#123; console.log(this) &#125;)&lt;/script&gt; 同样由于箭头函数 this 的原因，基于原型的面向对象也不推荐采用箭头函数，如下代码所示： 1234567891011&lt;script&gt; function Person() &#123; &#125; // 原型对像上添加了箭头函数 Person.prototype.walk = () =&gt; &#123; console.log(&#x27;人都要走路...&#x27;) console.log(this); // window &#125; const p1 = new Person() p1.walk()&lt;/script&gt; this指向以上归纳了普通函数和箭头函数中关于 this 默认值的情形，不仅如此 JavaScript 中还允许指定函数中 this 的指向，有 3 个方法可以动态指定普通函数中 this 的指向：call(),apply(),bind() call使用 call 方法调用函数，同时指定函数中 this 的值，使用方法如下代码所示： 123456789101112&lt;script&gt; const obj = &#123; uname: &#x27;pink&#x27; &#125; function fn(x, y) &#123; console.log(this) // window console.log(x + y) &#125; // 1. 调用函数 // 2. 改变 this 指向 fn.call(obj, 1, 2)&lt;/script&gt; 总结： call 方法能够在调用函数的同时指定 this 的值 使用 call 方法调用函数时，第1个参数为 this 指定的值 call 方法的其余参数会依次自动传入函数做为函数的参数 apply使用 call 方法调用函数，同时指定函数中 this 的值，使用方法如下代码所示： 123456789101112131415161718192021222324&lt;script&gt; const obj = &#123; age: 18 &#125; function fn(x, y) &#123; console.log(this) // &#123;age: 18&#125; console.log(x + y) &#125; // 1. 调用函数 // 2. 改变this指向 // fn.apply(this指向谁, 数组参数) fn.apply(obj, [1, 2]) // 3. 返回值 本身就是在调用函数，所以返回值就是函数的返回值 // 使用场景： 求数组最大值 // const max = Math.max(1, 2, 3) // console.log(max) const arr = [100, 44, 77] const max = Math.max.apply(Math, arr) const min = Math.min.apply(null, arr) console.log(max, min) // 使用场景： 求数组最大值 console.log(Math.max(...arr))&lt;/script&gt; 总结： apply 方法能够在调用函数的同时指定 this 的值 使用 apply 方法调用函数时，第1个参数为 this 指定的值 apply 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数 call与apply的区别在于参数不一样，apply传递的必须是数组 bindbind 方法并不会调用函数，而是创建一个指定了 this 值的新函数，使用方法如下代码所示： 1234567891011121314151617181920212223242526&lt;button&gt;发送短信&lt;/button&gt;&lt;script&gt;。、 const obj = &#123; age: 18 &#125; function fn() &#123; console.log(this) &#125; // 1. bind 不会调用函数 // 2. 能改变this指向 // 3. 返回值是个函数， 但是这个函数里面的this是更改过的obj const fun = fn.bind(obj) // console.log(fun) fun() // 需求，有一个按钮，点击里面就禁用，2秒钟之后开启 document.querySelector(&#x27;button&#x27;).addEventListener(&#x27;click&#x27;, function () &#123; // 禁用按钮 this.disabled = true window.setTimeout(function () &#123; // 在这个普通函数里面，我们要this由原来的window 改为 btn this.disabled = false &#125;.bind(this), 2000) // 这里的this 和 btn 一样 &#125;)&lt;/script&gt; 注：bind 方法创建新的函数，与原函数的唯一的变化是改变了 this 的值。 call apply bind总结 相同点： 都可以改变函数内部的this访问 区别点： call 和 apply 会调用函数，并且改变函数内部this指向 call 和 apply 传递的参数不一样，call传递参数aru1,aru2,…形式 apply必须使用数组形式 bind不会调用函数，可以改变函数内部this指向 主要应用场景： call调用函数并且可以传递函数 apply经常跟数组有关系，比如借助于数学对象实现数组最大值最小值 bind不调用函数，但是还可以改变this指向，比如改变定时器内部的this指向 四、防抖节流 防抖（debounce）所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间 节流（throttle）所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://wendy-ljw.github.io/tags/es6/"}]},{"title":"js高级-es6笔记(3)","slug":"js-es6-3","date":"2022-11-19T02:32:55.000Z","updated":"2022-11-23T09:36:15.179Z","comments":true,"path":"2022/11/19/js-es6-3/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/19/js-es6-3/","excerpt":"","text":"JavaScript 进阶 - 第3天 了解构造函数原型对象的语法特征，掌握 JavaScript 中面向对象编程的实现方式，基于面向对象编程思想实现 DOM 操作的封装。 了解面向对象编程的一般特征 掌握基于构造函数原型对象的逻辑封装 掌握基于原型对象实现的继承 理解什么原型链及其作用 能够处理程序异常提升程序执行的健壮性 一、面向对象 学习 JavaScript 中基于原型的面向对象编程序的语法实现，理解面向对象编程的特征。 面向对象编程是一种程序设计思想，它具有 3 个显著的特征：封装、继承、多态。 1.1 封装封装的本质是将具有关联的代码组合在一起，其优势是能够保证代码复用且易于维护，函数是最典型也是最基础的代码封装形式，面向对象思想中的封装仍以函数为基础，但提供了更高级的封装形式。 命名空间先来回顾一下以往代码封装的形式： 123456789101112131415&lt;script&gt; // 普通对象（命名空间）形式的封装 let beats = &#123; name: &#x27;狼&#x27;, setName: function (name) &#123; this.name = this.name; &#125;, getName() &#123; console.log(this.name); &#125; &#125; beats.setName(&#x27;熊&#x27;); beats.getName();&lt;/script&gt; 以往以普通对象（命名空间）形式封装的代码只是单纯把一系列的变量或函数组合到一起，所有的数据变量都被用来共享（使用 this 访问）。 构造函数对比以下通过面向对象的构造函数实现的封装： 12345678910111213141516171819202122&lt;script&gt; function Person() &#123; this.name = &#x27;佚名&#x27;; // 设置名字 this.setName = function (name) &#123; this.name = name; &#125; // 读取名字 this.getName = () =&gt; &#123; console.log(this.name); &#125; &#125; // 实例对像，获得了构造函数中封装的所有逻辑 let p1 = new Person(); p1.setName(&#x27;小明&#x27;); console.log(p1.name); // 实例对象 let p2 = new Person(); console.log(p2.name);&lt;/script&gt; 同样的将变量和函数组合到了一起并能通过 this 实现数据的共享，所不同的是借助构造函数创建出来的实例对象之间是彼此不影响的。 封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装前面我们学过的构造函数方法很好用，但是存在浪费内存的问题 总结： 构造函数体现了面向对象的封装特性 构造函数实例创建的对象彼此独立、互不影响 命名空间式的封装无法保证数据的独立性 注：可以举一些例子，如女娲造人等例子，加深对构造函数的理解。 原型对象实际上每一个构造函数都有一个名为 prototype 的属性，译成中文是原型的意思，prototype 的是对象类据类型，称为构造函数的原型对象，每个原型对象都具有 constructor 属性代表了该原型对象对应的构造函数。 12345678&lt;script&gt; function Person() &#123; &#125; // 每个函数都有 prototype 属性 console.log(Person.prototype);&lt;/script&gt; 了解了 JavaScript 中构造函数与原型对象的关系后，再来看原型对象具体的作用，如下代码所示： 1234567891011121314&lt;script&gt; function Person() &#123; // 此处未定义任何方法 &#125; // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () &#123; console.log(&#x27;Hi~&#x27;); &#125; // 实例化 let p1 = new Person(); p1.sayHi(); // 输出结果为 Hi~&lt;/script&gt; 构造函数 Person 中未定义任何方法，这时实例对象调用了原型对象中的方法 sayHi，接下来改动一下代码： 12345678910111213141516&lt;script&gt; function Person() &#123; // 此处定义同名方法 sayHi this.sayHi = function () &#123; console.log(&#x27;嗨!&#x27;); &#125; &#125; // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () &#123; console.log(&#x27;Hi~&#x27;); &#125; let p1 = new Person(); p1.sayHi(); // 输出结果为 嗨!&lt;/script&gt; 构造函数 Person 中定义与原型对象中相同名称的方法，这时实例对象调用则是构造函中的方法 sayHi。 通过以上两个简单示例不难发现 JavaScript 中对象的工作机制：当访问对象的属性或方法时，先在当前实例对象是查找，然后再去原型对象查找，并且原型对象被所有实例共享。 123456789101112131415161718192021&lt;script&gt; function Person() &#123; // 此处定义同名方法 sayHi this.sayHi = function () &#123; console.log(&#x27;嗨!&#x27; + this.name); &#125; &#125; // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () &#123; console.log(&#x27;Hi~&#x27; + this.name); &#125; // 在构造函数的原型对象上添加属性 Person.prototype.name = &#x27;小明&#x27;; let p1 = new Person(); p1.sayHi(); // 输出结果为 嗨! let p2 = new Person(); p2.sayHi();&lt;/script&gt; 总结：结合构造函数原型的特征，实际开发重往往会将封装的功能函数添加到原型对象中。 1.2 继承继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性。 龙生龙、凤生凤、老鼠的儿子会打洞描述的正是继承的含义，分别封装中国人和日本人的行为特征来理解编程中继承的含义，代码如下： 123456789101112131415161718192021222324252627282930313233&lt;script&gt; // 封装中国人的行为特征 function Chinese() &#123; // 中国人的特征 this.arms = 2; this.legs = 2; this.eyes = 2; this.skin = &#x27;yellow&#x27;; this.language = &#x27;中文&#x27;; // 中国人的行为 this.walk = function () &#123;&#125; this.sing = function () &#123;&#125; this.sleep = function () &#123;&#125; &#125; // 封装日本人的行为特征 function Japanese() &#123; // 日本人的特征 this.arms = 2; this.legs = 2; this.eyes = 2; this.skin = &#x27;yellow&#x27;; this.language = &#x27;日文&#x27;; // 日本人的行为 this.walk = function () &#123;&#125; this.sing = function () &#123;&#125; this.sleep = function () &#123;&#125; &#125;&lt;/script&gt; 其实我们都知道无论是中国人、日本人还是其它民族，人们的大部分特征是一致的，然而体现在代码中时人的相同的行为特征被重复编写了多次，代码显得十分冗余，我们可以将重复的代码抽离出来： 原型继承基于构造函数原型对象实现面向对象的继承特性。 12345678910111213141516171819202122232425&lt;script&gt; // 所有人 function Person() &#123; // 人的特征 this.arms = 2; this.legs = 2; this.eyes = 2; // 人的行为 this.walk = function () &#123;&#125; this.sing = function () &#123;&#125; this.sleep = function () &#123;&#125; &#125; // 中国人 function Chinese() &#123; this.skin = &#x27;yellow&#x27;; this.language = &#x27;中文&#x27;; &#125; // 日本人 function Japanese() &#123; this.skin = &#x27;yellow&#x27;; this.language = &#x27;日文&#x27;; &#125;&lt;/script&gt; 上述代码可以理解成将 Chinese 和 Japanese 共有的属性和方法提取出来了，也就是说 Chinese 和 Japanese 需要【共享】一些属性和方法，而原型对象的属性和方法恰好是可以被用来共享的，因此我们看如下代码： 12345678910111213141516171819202122232425262728&lt;script&gt; // 中国人 function Chinese() &#123; this.skin = &#x27;yellow&#x27;; this.language = &#x27;中文&#x27;; &#125; // 日本人 function Japanese() &#123; this.skin = &#x27;yellow&#x27;; this.language = &#x27;日文&#x27;; &#125; // 人们【共有】的行为特征 let people = &#123; // 人的特征 arms: 2, legs: 2, eyes:2, // 人的行为 walk: function () &#123;&#125;, sleep: function () &#123;&#125;, sing: function () &#123;&#125; &#125; // 为 prototype 重新赋值 Chinese.prototype = people; Chinese.prototype.constructor = Chinese;&lt;/script&gt; 如下图所示： 创建对象 people 将公共的的属性和方法独立出来，然后赋值给构造函数的 prototype 这样无论有多少个民族都可以共享公共的属性和方法了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script&gt; // 人们【共有】的行为特征 let people = &#123; // 人的特征 arms: 2, legs: 2, eyes:2, // 人的行为 walk: function () &#123;&#125;, sleep: function () &#123;&#125;, sing: function () &#123;&#125; &#125; // 中国人 function Chinese() &#123; this.skin = &#x27;yellow&#x27;; this.language = &#x27;中文&#x27;; &#125; // 日本人 function Japanese() &#123; this.skin = &#x27;yellow&#x27;; this.language = &#x27;日文&#x27;; &#125; function Englist() &#123; this.skin = &#x27;white&#x27;; this.language= &#x27;英文&#x27;; &#125; // 中国人 Chinese.prototype = people; Chinese.prototype.constructor = Chinese; let c1 = new Chinese(); // 日本人 Japanese.prototype = people; Janpanese.prototype.constructor = Japanese; // 英国人 English.prototype = people; English.prototype.constructor = English; // ...&lt;/script&gt; 继承是一种可以“不劳而获”的手段！！！上述代码中 Chinese、Japanese、English 都轻松的获得了 people 的公共的方法和属性，我们说 Chinese、Japanese、English 继承了 people。 上述代码中是以命名空间的形式实现的继承，事实上 JavaScript 中继承更常见的是借助构造函数来实现： 1234567891011121314151617181920212223242526272829303132333435363738&lt;script&gt; // 所有人 function Person() &#123; // 人的特征 this.arms = 2; this.legs = 2; this.eyes = 2; // 人的行为 this.walk = function () &#123;&#125; this.sing = function () &#123;&#125; this.sleep = function () &#123;&#125; &#125; // 封装中国人的行为特征 function Chinese() &#123; // 中国人的特征 this.skin = &#x27;yellow&#x27;; this.language = &#x27;中文&#x27;; &#125; // 封装日本人的行为特征 function Japanese() &#123; // 日本人的特征 this.skin = &#x27;yellow&#x27;; this.language = &#x27;日文&#x27;; &#125; // human 是构造函数 Person 的实例 let human = new Person(); // 中国人 Chinese.prototype = human; Chinese.prototype.constructor = Chinese; // 日本人 Japanese.prototype = human; Japanese.prototype.constructor = Japanese;&lt;/script&gt; 如下图所示： 原型链基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为原型链， 12345678910111213141516171819202122232425262728&lt;script&gt; // Person 构造函数 function Person() &#123; this.arms = 2; this.walk = function () &#123;&#125; &#125; // Person 原型对象 Person.prototype.legs = 2; Person.prototype.eyes = 2; Person.prototype.sing = function () &#123;&#125; Person.prototype.sleep = function () &#123;&#125; // Chinese 构造函数 function Chinese() &#123; this.skin = &#x27;yellow&#x27;; this.language = &#x27;中文&#x27;; &#125; // Chinese 原型对象 Chinese.prototype = new Person(); Chinese.prototype.constructor = Chinese; // 实例化 let c1 = new Chinese(); console.log(c1);&lt;/script&gt; 在 JavaScript 对象中包括了一个非标准备的属性 __proto__ 它指向了构造函数的原型对象，通过它可以清楚的查看原型对象的链状结构。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://wendy-ljw.github.io/tags/es6/"}]},{"title":"js高级-es6笔记(2)","slug":"js-es6-2","date":"2022-11-19T02:32:49.000Z","updated":"2022-11-23T08:20:49.996Z","comments":true,"path":"2022/11/19/js-es6-2/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/19/js-es6-2/","excerpt":"","text":"JavaScript 进阶 - 第2天 了解面向对象编程的基础概念及构造函数的作用，体会 JavaScript 一切皆对象的语言特征，掌握常见的对象属性和方法的使用。 了解面向对象编程中的一般概念 能够基于构造函数创建对象 理解 JavaScript 中一切皆对象的语言特征 理解引用对象类型值存储的的特征 掌握包装类型对象常见方法的使用 一、深入对象 了解面向对象的基础概念，能够利用构造函数创建对象。 创建对象三种方式 利用对象字面量创建对象 123const o = &#123; name: &#x27;Lili&#x27;&#125; 利用new Object创建对象 12const o = new Object(&#123; name: &#x27;Lili&#x27;&#125;)console.log(o) // &#123;name: &#x27;Lili&#x27;&#125; 利用构造函数创建对象 1.1 构造函数构造函数是专门用于创建对象的函数，如果一个函数使用 new 关键字调用，那么这个函数就是构造函数。 使用场景：常规的{···}语法允许创建一个对象，但继续创建相似对象还需重新写。此时可以通过构造函数来快速创建多个类似的对象。 12345678910function Pig(name , age , gender)&#123; this.name = name this.age = age this.gender = gender&#125;const Peppa = new Pig(&#x27;佩奇&#x27;,6,&#x27;女&#x27;)const Peppa1 = new Pig(&#x27;佩奇1&#x27;,7,&#x27;女&#x27;)const Peppa2 = new Pig(&#x27;佩奇2&#x27;,8,&#x27;男&#x27;)const Peppa3 = new Pig(&#x27;佩奇3&#x27;,9,&#x27;女&#x27;) 12345678&lt;script&gt; // 定义函数 function foo() &#123; console.log(&#x27;通过 new 也能调用函数...&#x27;); &#125; // 调用函数 new foo;&lt;/script&gt; 总结： new Object() new Date() 也是实例化构造函数 使用 new 关键字调用函数的行为被称为实例化 实例化构造函数时没有参数时可以省略 ()，但不提倡 构造函数的返回值即为新创建的对象，所以不要写return 构造函数内部的 return 返回的值无效！ 注：实践中为了从视觉上区分构造函数和普通函数，习惯将构造函数的首字母大写。 实例化执行过程 创建新对象 构造函数this指向新对象 执行构造函数代码，修改this，添加新的属性 返回新对象 1.2 实例成员通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。 123456789101112131415161718&lt;script&gt; // 构造函数 function Person() &#123; // 构造函数内部的 this 就是实例对象 // 实例对象中动态添加属性 this.name = &#x27;小明&#x27; // 实例对象动态添加方法 this.sayHi = function () &#123; console.log(&#x27;大家好~&#x27;) &#125; &#125; // 实例化，p1 是实例对象 // p1 实际就是 构造函数内部的 this const p1 = new Person() console.log(p1) console.log(p1.name) // 访问实例属性 p1.sayHi() // 调用实例方法&lt;/script&gt; 总结： 构造函数内部 this 实际上就是实例对象，为其动态添加的属性和方法即为实例成员 为构造函数传入参数，动态创建结构相同但值不同的对象 注：构造函数创建的实例对象彼此独立互不影响。 1.3 静态成员在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。 123456789101112131415&lt;script&gt; // 构造函数 function Person(name, age) &#123; // 省略实例成员 &#125; // 静态属性 Person.eyes = 2 Person.arms = 2 // 静态方法 Person.walk = function () &#123; console.log(&#x27;^_^人都会走路...&#x27;) // this 指向 Person console.log(this.eyes) &#125;&lt;/script&gt; 总结： 静态成员指的是添加到构造函数本身的属性和方法 一般公共特征的属性或方法静态成员设置为静态成员 静态成员方法中的 this 指向构造函数本身 二、内置构造函数 掌握各引用类型和包装类型对象属性和方法的使用。 在 JavaScript 中最主要的数据类型有 6 种，分别是字符串、数值、布尔、undefined、null 和 对象，常见的对象类型数据包括数组和普通对象。其中字符串、数值、布尔、undefined、null 也被称为简单类型或基础类型，对象也被称为引用类型。 在 JavaScript 内置了一些构造函数，绝大部的数据处理都是基于这些构造函数实现的，JavaScript 基础阶段学习的 Date 就是内置的构造函数。 1234567&lt;script&gt; // 实例化 let date = new Date(); // date 即为实例对象 console.log(date);&lt;/script&gt; 甚至字符串、数值、布尔、数组、普通对象也都有专门的构造函数，用于创建对应类型的数据。 2.1 引用类型ObjectObject 是内置的构造函数，用于创建普通对象。 三个常用的静态方法 静态方法就是只有构造函数和Object可以调用的方法 1234567891011121. Object.keys获得所有的属性名const o = &#123; uname: &#x27;pink&#x27;, age: 18 &#125;console.log(Object.keys(o)) //返回数组[&#x27;uname&#x27;, &#x27;age&#x27;]2. Object.values获得所有的属性值console.log(Object.values(o)) // [&#x27;pink&#x27;, 18]3. Object.assign对象的拷贝 // const oo = &#123;&#125; // Object.assign(oo, o) // console.log(oo)Object.assign(o, &#123; gender: &#x27;女&#x27; &#125;)console.log(o) 总结： 推荐使用字面量方式声明对象，而不是 Object 构造函数 Object.assign 静态方法创建新的对象 Object.keys 静态方法获取对象中所有属性 Object.values 表态方法获取对象中所有属性值 ArrayArray 是内置的构造函数，用于创建数组。 12345678&lt;script&gt; // 构造函数创建数组 let arr = new Array(5, 7, 8); // 字面量方式创建数组 let list = [&#x27;html&#x27;, &#x27;css&#x27;, &#x27;javascript&#x27;]&lt;/script&gt; 数组赋值后，无论修改哪个变量另一个对象的数据值也会相当发生改变。 reduce 累计器 返回函数是累计处理的结果，经常用于求和等语法：arr.reduce(function(累计值,当前元素 [,索引号][,源数组])&#123;&#125;,起始值)参数： 如果有起始值，则以起始值为准开始累计，累计值&#x3D;起始值 如果没有起始值，则累计值以数组的第一个数组元素作为起始值开始累计 后面每次遍历就会用后面的数组元素 累计到累计值里面(类似求和里面的sum) 1234567891011121314151617181920212223242526272829303132const arr = [ &#123; name: &#x27;小米&#x27;, price: 1999 &#125;, &#123; name: &#x27;华为&#x27;, price: 3999 &#125;, ]// 1. find 查找const mi = arr.find(item =&gt; item.name === &#x27;小米&#x27;)console.log(mi)// 2. every 每一个是否都符合条件，如果都符合返回 true ，否则返回falseconst arr1 = [10, 20, 30]const flag = arr1.every(item =&gt; item &gt;= 20)console.log(flag)const spec = &#123; size: &#x27;40cm*40cm&#x27;, color: &#x27;黑色&#x27; &#125;//1. 所有的属性值回去过来 数组console.log(Object.values(spec))// 2. 转换为字符串 数组join(&#x27;/&#x27;) 把数组根据分隔符转换为字符串console.log(Object.values(spec).join(&#x27;/&#x27;))document.querySelector(&#x27;div&#x27;).innerHTML = Object.values(spec).join(&#x27;/&#x27;)// Array.from(lis) 把伪数组转换为真数组const lis = document.querySelectorAll(&#x27;ul li&#x27;)// console.log(lis)// lis.pop() 报错const liss = Array.from(lis)liss.pop()console.log(liss) 总结： 推荐使用字面量方式声明数组，而不是 Array 构造函数 实例方法 forEach 用于遍历数组，替代 for 循环 (重点) 实例方法 filter 过滤数组单元值，生成新数组(重点) 实例方法 map 迭代原数组，生成新数组(重点) 实例方法 join 数组元素拼接为字符串，返回字符串(重点) 实例方法 find 查找元素， 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined(重点) 实例方法every 检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回 true，否则返回 false(重点) 实例方法some 检测数组中的元素是否满足指定条件 如果数组中有元素满足条件返回 true，否则返回 false 实例方法 concat 合并两个数组，返回生成新数组 实例方法 sort 对原数组单元值排序 实例方法 splice 删除或替换原数组单元 实例方法 reverse 反转数组 实例方法 findIndex 查找元素的索引值 ​ 2.2 包装类型在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，如下代码举例： 1234567891011&lt;script&gt; // 字符串类型 const str = &#x27;hello world!&#x27; // 统计字符的长度（字符数量） console.log(str.length) // 数值类型 const price = 12.345 // 保留两位小数 price.toFixed(2) // 12.34&lt;/script&gt; 之所以具有对象特征的原因是字符串、数值、布尔类型数据是 JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型。 StringString 是内置的构造函数，用于创建字符串。 1234567891011&lt;script&gt; // 使用构造函数创建字符串 let str = new String(&#x27;hello world!&#x27;); // 字面量创建字符串 let str2 = &#x27;你好，世界！&#x27;; // 检测是否属于同一个构造函数 console.log(str.constructor === str2.constructor); // true console.log(str instanceof String); // false&lt;/script&gt; 123456789101112131415161718//1. split 把字符串 转换为 数组 和 join() 相反const str = &#x27;pink,red&#x27;const arr = str.split(&#x27;,&#x27;)console.log(arr)const str1 = &#x27;2022-4-8&#x27;const arr1 = str1.split(&#x27;-&#x27;)console.log(arr1)//2. 字符串的截取 substring(开始的索引号[， 结束的索引号])//2.1 如果省略 结束的索引号，默认取到最后//2.2 结束的索引号不包含想要截取的部分const str = &#x27;今天又要做核酸了&#x27;console.log(str.substring(5, 7))//3. startsWith 判断是不是以某个字符开头const str = &#x27;pink老师上课中&#x27;console.log(str.startsWith(&#x27;pink&#x27;))//4. includes 判断某个字符是不是包含在一个字符串里面const str = &#x27;我是pink老师&#x27;console.log(str.includes(&#x27;pink&#x27;)) // true 总结： 实例属性 length 用来获取字符串的度长(重点) 实例方法 split(&#39;分隔符&#39;) 用来将字符串拆分成数组(重点) 实例方法 substring（需要截取的第一个字符的索引[,结束的索引号]） 用于字符串截取(重点) 实例方法 startsWith(检测字符串[, 检测位置索引号]) 检测是否以某字符开头(重点) 实例方法 includes(搜索的字符串[, 检测位置索引号]) 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点) 实例方法 toUpperCase 用于将字母转换成大写 实例方法 toLowerCase 用于将就转换成小写 实例方法 indexOf 检测是否包含某字符 实例方法 endsWith 检测是否以某字符结尾 实例方法 replace 用于替换字符串，支持正则匹配 实例方法 match 用于查找字符串，支持正则匹配 注：String 也可以当做普通函数使用，这时它的作用是强制转换成字符串数据类型。 NumberNumber 是内置的构造函数，用于创建数值。 123456789101112131415&lt;script&gt; // 使用构造函数创建数值 let x = new Number(&#x27;10&#x27;) let y = new Number(5) // 字面量创建数值 let z = 20// toFixed 方法可以让数字指定保留的小数位数const num = 10.923// console.log(num.toFixed())console.log(num.toFixed(1))const num1 = 10console.log(num1.toFixed(2))&lt;/script&gt; 总结： 推荐使用字面量方式声明数值，而不是 Number 构造函数 实例方法 toFixed 用于设置保留小数位的长度","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://wendy-ljw.github.io/tags/es6/"}]},{"title":"js高级-es6笔记","slug":"js-es6-1","date":"2022-11-17T02:35:20.000Z","updated":"2022-11-19T02:37:11.827Z","comments":true,"path":"2022/11/17/js-es6-1/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/17/js-es6-1/","excerpt":"","text":"JavaScript 进阶 - 第1天 学习作用域、变量提升、闭包等语言特征，加深对 JavaScript 的理解，掌握变量赋值、函数声明的简洁语法，降低代码的冗余度。 理解作用域对程序执行的影响 能够分析程序执行的作用域范围 理解闭包本质，利用闭包创建隔离作用域 了解什么变量提升及函数提升 掌握箭头函数、解析剩余参数等简洁语法 一、作用域 了解作用域对程序执行的影响及作用域链的查找机制，使用闭包函数创建隔离作用域避免全局变量污染。 作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问，作用域分为全局作用域和局部作用域。 1.1 局部作用域局部作用域分为函数作用域和块作用域。 函数作用域在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。 &lt;script&gt; // 声明 counter 函数 function counter(x, y) &#123; // 函数内部声明的变量 const s = x + y console.log(s) // 18 &#125; // 设用 counter 函数 counter(10, 8) // 访问变量 s console.log(s)// 报错&lt;/script&gt; 总结： 函数内部声明的变量，在函数外部无法被访问 函数的参数也是函数内部的局部变量 不同函数内部声明的变量无法互相访问 函数执行完毕后，函数内部的变量实际被清空了 块作用域在 JavaScript 中使用 &#123;&#125; 包裹的代码称为代码块，代码块内部声明的变量外部将有可能无法被访问。 &lt;script&gt; &#123; // age 只能在该代码块中被访问 let age = 18; console.log(age); // 正常 &#125; // 超出了 age 的作用域 console.log(age) // 报错 let flag = true; if(flag) &#123; // str 只能在该代码块中被访问 let str = &#x27;hello world!&#x27; console.log(str); // 正常 &#125; // 超出了 str 的作用域 console.log(str); // 报错 for(let t = 1; t &lt;= 6; t++) &#123; // t 只能在该代码块中被访问 console.log(t); // 正常 &#125; // 超出了 t 的作用域 console.log(t); // 报错&lt;/script&gt; JavaScript 中除了变量外还有常量，常量与变量本质的区别是常量必须要有值且不允许被重新赋值，常量值为对象时其属性和方法允许重新赋值。 &lt;script&gt; // 必须要有值 const version = &#x27;1.0.0&#x27;; // 不能重新赋值 // version = &#x27;1.0.1&#x27;; // 常量值为对象类型 const user = &#123; name: &#x27;小明&#x27;, age: 18 &#125; // 不能重新赋值 user = &#123;&#125;; // 属性和方法允许被修改 user.name = &#x27;小小明&#x27;; user.gender = &#x27;男&#x27;;&lt;/script&gt; 总结： let 声明的变量会产生块作用域，var 不会产生块作用域 const 声明的常量也会产生块作用域 不同代码块之间的变量无法互相访问 推荐使用 let 或 const 注：开发中 let 和 const 经常不加区分的使用，如果担心某个值会不小被修改时，则只能使用 const 声明成常量。 1.2 全局作用域&lt;script&gt; 标签和 .js 文件的最外层就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。 &lt;script&gt; // 此处是全局 function sayHi() &#123; // 此处为局部 &#125; // 此处为全局&lt;/script&gt; 全局作用域中声明的变量，任何其它作用域都可以被访问，如下代码所示： &lt;script&gt; // 全局变量 name const name = &#x27;小明&#x27; // 函数作用域中访问全局 function sayHi() &#123; // 此处为局部 console.log(&#x27;你好&#x27; + name) &#125; // 全局变量 flag 和 x const flag = true let x = 10 // 块作用域中访问全局 if(flag) &#123; let y = 5 console.log(x + y) // x 是全局的 &#125;&lt;/script&gt; 总结： 为 window 对象动态添加的属性默认也是全局的，不推荐！ 函数中未使用任何关键字声明的变量为全局变量，不推荐！！！ 尽可能少的声明全局变量，防止全局变量被污染 JavaScript 中的作用域是程序被执行时的底层机制，了解这一机制有助于规范代码书写习惯，避免因作用域导致的语法错误。 1.3 作用域链在解释什么是作用域链前先来看一段代码： &lt;script&gt; // 全局作用域 let a = 1 let b = 2 // 局部作用域 function f() &#123; let c // 局部作用域 function g() &#123; let d = &#x27;yo&#x27; &#125; &#125;&lt;/script&gt; 函数内部允许创建新的函数，f 函数内部创建的新函数 g，会产生新的函数作用域，由此可知作用域产生了嵌套的关系。 如下图所示，父子关系的作用域关联在一起形成了链状的结构，作用域链的名字也由此而来。 作用域链本质上是底层的变量查找机制，在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域，如下代码所示： &lt;script&gt; // 全局作用域 let a = 1 let b = 2 // 局部作用域 function f() &#123; let c // let a = 10; console.log(a) // 1 或 10 console.log(d) // 报错 // 局部作用域 function g() &#123; let d = &#x27;yo&#x27; // let b = 20; console.log(b) // 2 或 20 &#125; // 调用 g 函数 g() &#125; console.log(c) // 报错 console.log(d) // 报错 f();&lt;/script&gt; 总结： 嵌套关系的作用域串联起来形成了作用域链 相同作用域链中按着从小到大的规则查找变量 子作用域能够访问父作用域，父级作用域无法访问子级作用域 1.4 垃圾回收机制1.4.1 什么是垃圾回收机制？垃圾回收机制（Garbage Collection) 简称 GCJS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收 1.4.2 内存泄漏正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法回收）的情况不再用到的内存，没有及时释放，就叫做内存泄漏 1.4.3 内存的生命周期JS环境中分配的内存，一般有如下生命周期： 内存分配： 当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 内存使用： 即读写内存，也就是使用变量、函数等 内存回收： 使用完毕，由垃圾回收自动回收不再使用的内容 说明： 全局变量一般不会回收（关闭页面回收）； 一般情况下局部变量的值，不用了会被自动回收掉 1.4.4 垃圾回收算法说明所谓垃圾回收，核心思想就是如何判断内存是否已经不再会被使用了，如果是，就视为垃圾，释放掉有两种常见的浏览器垃圾回收算法： 引用计数法和标记清除法 引用计数IE采用的引用计数算法，定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。算法： 跟踪记录每个值被引用的次数。 如果这个值的被引用了一次，那么就记录次数加1 多次引用会累加 如果减少一个引用就减1 如果引用次数是0，则释放内存&lt;script&gt; const person=&#123; //定义了person，引用次数为1 age:18, name:&#x27;ljw&#x27; &#125; const p=person //因为引用的是地址，所以引用次数加一 person=1 //person不再指向原来的结构体，所以引用次数减一 p=null //p也不再指向原来的结构体，所以引用次数减一 //此时引用次数为0，释放内存&lt;/script&gt; 由上面可以看出，引用计数算法是个简单有效的算法。但它却存在一个致命的问题：嵌套引用如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄漏。 &lt;script&gt; function fn()&#123; let o1 = &#123;&#125; let o2 = &#123;&#125; o1.a = o2 o2.a = o1 return &#x27;引用计数无法回收&#x27; &#125; fn()&lt;/script&gt; 因为他们的引用次数永远不会是0，这样的相互引用如果很大量的存在就会导致大量的内存泄漏 标记清除法 现在的浏览器已经不再使用引用计数算法了。现在浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。核心： 标记清除算法将“不再使用的对象”定义为“无法达到的对象” 就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收 1.5 闭包闭包（closure）是一种比较特殊和函数，使用闭包能够访问函数作用域中的变量。一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域 闭包&#x3D;内层函数+外层函数的变量 从代码形式上看闭包是一个做为返回值的函数，如下代码所示： &lt;script&gt; function foo() &#123; let i = 0; // 函数内部分函数 function bar() &#123; console.log(++i); &#125; // 将函数做为返回值 return bar; &#125; // fn 即为闭包函数 let fn = foo(); fn(); // 1&lt;/script&gt; 常见闭包的形式：外部可以访问使用函数内部的变量 总结： 闭包本质仍是函数，只不是从函数内部返回的 闭包能够创建外部可访问的隔离作用域，避免全局变量污染 过度使用闭包可能造成内存泄漏 注：回调函数也能访问函数内部的局部变量。 1.6 变量提升变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问。 把所有var声明的变量提升到当前作用域的最前面，只提升声明，不提升赋值 &lt;script&gt; // 访问变量 str console.log(str + &#x27;world!&#x27;); // 声明变量 str var str = &#x27;hello &#x27;;&lt;/script&gt; 总结： 变量在未声明即被访问时会报语法错误 变量在声明之前即被访问，变量的值为 undefined let 声明的变量不存在变量提升，推荐使用 let 变量提升出现在相同作用域当中 实际开发中推荐先声明再访问变量 注：关于变量提升的原理分析会涉及较为复杂的词法分析等知识，而开发中使用 let 可以轻松规避变量的提升，因此在此不做过多的探讨，有兴趣可查阅资料。 二、函数 知道函数参数默认值、动态参数、剩余参数的使用细节，提升函数应用的灵活度，知道箭头函数的语法及与普通函数的差异。 2.1 函数提升函数提升与变量提升比较类似，是指函数在声明之前即可被调用。 会把所有函数声明提升到当前作用域的最前面只提升函数声明，不提升函数调用 &lt;script&gt; // 调用函数 foo() // 声明函数 function foo() &#123; console.log(&#x27;声明之前即被调用...&#x27;) &#125; // 不存在提升现象 bar() // 错误 var bar = function () &#123; //因为变量被提升了，但是函数赋值没有被提升 console.log(&#x27;函数表达式不存在提升现象...&#x27;) &#125;&lt;/script&gt; 总结： 函数提升能够使函数的声明调用更灵活 函数表达式不存在提升的现象 函数提升出现在相同作用域当中 2.2 参数函数参数的使用细节，能够提升函数应用的灵活度。 默认值&lt;script&gt; // 设置参数默认值 function sayHi(name=&quot;小明&quot;, age=18) &#123; document.write(`&lt;p&gt;大家好，我叫$&#123;name&#125;，我今年$&#123;age&#125;岁了。&lt;/p&gt;`); &#125; // 调用函数 sayHi(); sayHi(&#x27;小红&#x27;); sayHi(&#x27;小刚&#x27;, 21);&lt;/script&gt; 总结： 声明函数时为形参赋值即为参数的默认值 如果参数未自定义默认值时，参数的默认值为 undefined 调用函数时没有传入对应实参时，参数的默认值被当做实参传入 动态参数arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参。 &lt;script&gt; // 求生函数，计算所有参数的和 function sum() &#123; // console.log(arguments) let s = 0 for(let i = 0; i &lt; arguments.length; i++) &#123; s += arguments[i] &#125; console.log(s) &#125; // 调用求和函数 sum(5, 10)// 两个参数 sum(1, 2, 4) // 两个参数&lt;/script&gt; 总结： arguments 是一个伪数组 arguments 的作用是动态获取函数的实参 剩余参数&lt;script&gt; function config(baseURL, ...other) &#123; console.log(baseURL) // 得到 &#x27;http://baidu.com&#x27; console.log(other) // other 得到 [&#x27;get&#x27;, &#x27;json&#x27;] &#125; // 调用函数 config(&#x27;http://baidu.com&#x27;, &#x27;get&#x27;, &#x27;json&#x27;);&lt;/script&gt; 总结： ... 是语法符号，置于最末函数形参之前，用于获取多余的实参 借助 ... 获取的剩余实参，是个真数组 展开运算符展开运算符（…），将一个数组进行展开 const arr = [1,2,3,4,5]console.log(...arr) // 1 2 3 4 5 不会改变原数组 典型运用场景：求数组最大值（最小值）、合并数组等 //求最值console.log(Math.max(...arr))console.log(Math.min(...arr))//合并数组const arr2 = [3,4,5]const arr = [...arr1,...arr2] 展开运算符的剩余参数的区别：剩余参数：函数参数使用，得到真数组展开运算符：数组中使用，数组展开 2.3 箭头函数箭头函数是一种声明函数的简洁语法，它与普通函数并无本质的区别，差异性更多体现在语法格式上。 引入箭头函数的目的是更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁箭头函数更适用于那些本来需要匿名函数的地方 &lt;script&gt; // 箭头函数 const foo = () =&gt; &#123; //本行相当于 const foo = function () &#123; console.log(&#x27;^_^ 长相奇怪的函数...&#x27;); &#125; // 调用函数 foo() //只有一个参数时可以省略圆括号 () const fn = a =&gt; &#123; console.log(a) &#125; //函数体只有一行代码时可以省略花括号 `&#123;&#125;`，并自动做为返回值被返回 const fn = a =&gt; a + a // 更简洁的语法 const form = document.querySelector(&#x27;form&#x27;) form.addEventListener(&#x27;click&#x27;, ev =&gt; ev.preventDefault()) //可以直接返回一个对象 const fn = (uname) =&gt; (&#123; uname: uname &#125;)&lt;/script&gt; 箭头函数中的this // 以前this的指向： 谁调用的这个函数，this 就指向谁 console.log(this) // window // 普通函数 function fn() &#123; console.log(this) // window &#125; window.fn() // 对象方法里面的this const obj = &#123; name: &#x27;andy&#x27;, sayHi: function () &#123; console.log(this) // obj &#125; &#125; obj.sayHi()// 2. 箭头函数的this 是上一层作用域的this 指向 const fn = () =&gt; &#123; console.log(this) // window &#125; fn()// 对象方法箭头函数 this const obj = &#123; uname: &#x27;pink老师&#x27;, sayHi: () =&gt; &#123; console.log(this) // this 指向谁？ window &#125; &#125; obj.sayHi()const obj = &#123; uname: &#x27;pink老师&#x27;, sayHi: function () &#123; console.log(this) // obj let i = 10 const count = () =&gt; &#123; console.log(this) // obj &#125; count() &#125;&#125;obj.sayHi() 总结： 箭头函数属于表达式函数，因此不存在函数提升 箭头函数只有一个参数时可以省略圆括号 () 箭头函数函数体只有一行代码时可以省略花括号 &#123;&#125;，并自动做为返回值被返回 箭头函数中没有 arguments，只能使用剩余函数 ... 动态获取实参 箭头函数不会创建自己的this,它只会从自己的作用域链的上一层延用this DOM事件回调函数不推荐使用箭头函数，特别是要用到this的时候 事件回调函数使用箭头函数时，this为全局的window 三、解构赋值 知道解构的语法及分类，使用解构简洁语法快速为变量赋值。 解构赋值是一种快速为变量赋值的简洁语法，本质上仍然是为变量赋值，分为数组解构、对象解构两大类型。 3.1 数组解构数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法，如下代码所示： &lt;script&gt; // 普通的数组 let arr = [1, 2, 3]; // 批量声明变量 a b c // 同时将数组单元值 1 2 3 依次赋值给变量 a b c let [a, b, c] = arr; console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 let a = 1 let b = 2; //这里必须加分号 [b,a]=[a,b] //交换变量值&lt;/script&gt; 数组解构的细节 // 1. 变量多， 单元值少 ， undefined const [a, b, c, d] = [1, 2, 3] console.log(a) // 1 console.log(b) // 2 console.log(c) // 3 console.log(d) // undefined// 2. 变量少， 单元值多 const [a, b] = [1, 2, 3] console.log(a) // 1 console.log(b) // 2// 3. 剩余参数 变量少， 单元值多 const [a, b, ...c] = [1, 2, 3, 4] console.log(a) // 1 console.log(b) // 2 console.log(c) // [3, 4] 真数组// 4. 防止 undefined 传递 const [a = 0, b = 0] = [1, 2] const [a = 0, b = 0] = [] console.log(a) // 1 console.log(b) // 2// 5. 按需导入赋值 const [a, b, , d] = [1, 2, 3, 4] console.log(a) // 1 console.log(b) // 2 console.log(d) // 4 const arr = [1, 2, [3, 4]] console.log(arr[0]) // 1 console.log(arr[1]) // 2 console.log(arr[2]) // [3,4] console.log(arr[2][0]) // 3// 多维数组解构 const arr = [1, 2, [3, 4]] const [a, b, c] = [1, 2, [3, 4]] console.log(a) // 1 console.log(b) // 2 console.log(c) // [3,4]const [a, b, [c, d]] = [1, 2, [3, 4]]console.log(a) // 1console.log(b) // 2console.log(c) // 3console.log(d) // 4 总结： 赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量 变量的顺序对应数组单元值的位置依次进行赋值操作 变量的数量大于单元值数量时，多余的变量将被赋值为 undefined 变量的数量小于单元值数量时，可以通过 ... 获取剩余单元值，但只能置于最末位 允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效 注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析 3.2 对象解构对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法，如下代码所示： &lt;script&gt; // 普通对象 const user = &#123; name: &#x27;小明&#x27;, age: 18 &#125;; // 批量声明变量 name age // 同时将数组单元值 小明 18 依次赋值给变量 name age const &#123;name, age&#125; = user const &#123;name, age&#125; = &#123;name: &#x27;lili&#x27;,age: 18&#125; console.log(name) // 小明 console.log(age) // 18 //对象解构的变量名 可以重新改名 旧变量名: 新变量名 const &#123; uname: username, age &#125; = &#123; uname: &#x27;pink&#x27;, age: 18 &#125; console.log(username) console.log(age) // 解构数组对象 const pig = [ &#123; uname: &#x27;佩奇&#x27;, age: 6 &#125; ] const [&#123; uname, age &#125;] = pig console.log(uname) console.log(age) &lt;/script&gt; 多级对象解构 const person = [ &#123; name: &#x27;佩奇&#x27;, family: &#123; mother: &#x27;猪妈妈&#x27;, father: &#x27;猪爸爸&#x27;, sister: &#x27;乔治&#x27; &#125;, age: 6 &#125; ] const [&#123; name, family: &#123; mother, father, sister &#125; &#125;] = person console.log(name) console.log(mother) console.log(father) console.log(sister) 总结： 赋值运算符 = 左侧的 &#123;&#125; 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量 对象属性的值将被赋值给与属性名相同的变量 对象中找不到与变量名一致的属性时变量值为 undefined 允许初始化变量的默认值，属性不存在或单元值为 undefined 时默认值才会生效 注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析 两种必须加分号的情况 // 1. 立即执行函数要加 (function () &#123; &#125;)(); (function () &#123; &#125;)();// 2. 使用数组的时候// const arr = [1, 2, 3]const str = &#x27;pink&#x27;;[1, 2, 3].map(function (item) &#123; console.log(item)&#125;)let a = 1let b = 2 ;[b, a] = [a, b]console.log(a, b) forEach遍历数组放法forEach()方法用于调用数组的每个元素，并将元素传递给回调函数 被遍历的数组.forEach(function(当前数组元素，当前元素索引号)&#123; //函数体&#125;)// forEach 就是遍历 加强版的for循环 适合于遍历数组对象const arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;pink&#x27;]const result = arr.forEach(function (item, index) &#123; console.log(item) // 数组元素 red green pink console.log(index) // 索引号&#125;)// console.log(result) 注意：1.forEach主要是遍历数组2. 参数当前数组元素是必须要写的，索引号可选适合于遍历数组对象 filter筛选数组方法filter方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素主要使用场景：**筛选符合条件的元素，并返回筛选之后元素的新数组返回值： 返回数组，包含了符合条件的所有元素，如果没有符合条件的元素则返回空数组 被遍历的数组.filter(function (currentValue,index)&#123; return 筛选条件&#125;)const newArr = arr.filter(item =&gt; item &gt;= 20) console.log(newArr)","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://wendy-ljw.github.io/tags/es6/"}]},{"title":"git学习笔记","slug":"git-note","date":"2022-11-15T09:27:28.000Z","updated":"2022-11-16T13:55:43.696Z","comments":true,"path":"2022/11/15/git-note/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/15/git-note/","excerpt":"","text":"Git实战听故事顺便学git，可能是全世界最好玩的git教程。 第一章 快速入门1.1 什么是GitGit是一个分布式的版本控制软件。 软件，类似于QQ、office、dota等安装到电脑上才能使用的工具。 版本控制，类似于毕业论文、写文案、视频剪辑等，需要反复修改和保留原历史数据。 分布式 文件夹拷贝 本地版本控制 集中式版本控制 分布式版本控制 1.2 为什么要做版本控制要保留之前所有的版本，以便回滚和修改。 1.3 安装git详见：https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git 1.4 git三大区域 工作区（红色区域） 已管理文件中的新增文件或修改文件（自动检测） 目的：方便写代码，方便修改，把改变的部分放这 暂存区（绿色区域） 把工作区里的文件用git add提交到暂存区 目的：起到一个缓冲的作用，是工作区与版本库的过度区域 版本库 把暂存区里的文件用git commit提交到版本库 目的：最终的每一个版本都放在这 第二章 “东北热”创业史2.1 第一阶段：单枪匹马开始干想要让git对一个目录进行版本控制需要以下步骤： 进入要管理的文件夹 执行初始化命令 git init 管理目录下的文件状态 git status注：新增的文件和修改过后的文件都是红色 管理指定文件（红变绿） git add 文件名git add . 个人信息配置：用户名、邮箱 【一次即可】 git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 生成版本 git commit -m &#x27;描述信息&#x27; //单引号中主要放对版本的描述信息，如初稿，版本号等 查看版本记录 git log 2.2 第二阶段：拓展新功能git add git commit -m &#x27;短视频&#x27; 新增了有短视频功能的版本 2.3 第三阶段：“约饭事件” 回滚至之前版本 git log git reset --hard 版本号 版本号指的是git log执行后输出的commit后面的一大串字母数字 回滚至之后版本 git reflog git reset --hard 版本号 这里的版本号是git reflog执行后输出的每一行最前面的一小串字母数字 2.4 小总结git init git add git commit git log git reflog git reset --hard 版本号 2.5 第四阶段：商城&amp;紧急修复bug2.5.1 分支分支可以给使用者提供多个环境的可以，意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 2.5.2 紧急修复bug方案 2.5.3 命令总结 查看分支 git branch 创建分支 git branch 分支名称 切换分支 git checkout 分支名称 分支合并（可能产生冲突） git merge 要合并的分支注意：切换分支再合并 删除分支 git branch -d 分支名称 2.5.4 工作流 2.6 第五阶段：进军三里屯有钱之后就要造呀，一个人在三里屯买了一层楼做办公室。 2.6.1 第一天上班前在家上传代码首先，需要注册github账号，并创建远程仓库，然后再执行如下命令，将代码上传到github。 1. 给远程仓库起别名 git remote add origin 远程仓库地址2. 向远程推送代码 git push -u origin 分支 2.6.2 初次在公司新电脑下载代码1. 克隆远程仓库代码 git clone 远程仓库地址 (内部已实现git remote add origin 远程仓库地址)2. 切换分支 git checkout 分支 在公司下载完代码后，继续开发 1. 切换到dev分支进行开发 git checkout dev 2. 把master分支合并到dev [仅一次] git merge master3. 修改代码4. 提交代码 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.3 下班回到家继续写代码1. 切换到dev分支进行开发 git checkout dev 2. 拉代码 git pull origin dev 3. 继续开发4. 提交代码 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.4 到公司继续开发1. 切换到dev分支进行开发 git checkout dev 2. 拉最新代码(不必再clone，只需要通过pull获取最新代码即可) git pull origin dev 3. 继续开发4. 提交代码 git add . git commit -m &#x27;xx&#x27; git push origin dev 开发完毕，要上线 1. 将dev分支合并到master，进行上线 git checkout master git merge dev git push origin master2. 把dev分支也推送到远程 git checkout dev git merge master git push origin dev 2.6.5 在公司约妹子忘记提交代码1. 拉代码 git pull origin dev 2. 继续开发3. 提交代码 git add . git commit -m &#x27;xx&#x27;注：忘记push了 2.6.6 回家继续写代码1. 拉代码，发现在公司写的代码忘记提交... git pull origin dev 2. 继续开发其他功能 3. 把dev分支也推送到远程 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.7 到公司继续写代码1. 拉代码，把晚上在家写的代码拉到本地(有合并、可能产生冲突) git pull origin dev 2. 如果有冲突，手动解决冲突 3. 继续开发其他功能 4. 把dev分支也推送到远程 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.8 其他git pull origin dev等价于git fetch origin devgit merge origin/dev 2.6.9 rebase的作用？rebase可以保持提交记录简洁，不分叉。 2.6.9 快速解决冲突 安装beyond compare 在git中配置 git config --local merge.tool bc3git config --local mergetool.path &#x27;/usr/local/bin/bcomp&#x27;git config --local mergetool.keepBackup false 应用beyond compare 解决冲突 git mergetool 2.7 小总结 添加远程连接（别名） git remote add origin 地址 推送代码 git push origin dev 下载代码 git clone 地址 拉取代码 git pull origin dev 等价于git fetch origin devgit merge origin/dev 保持代码提交整洁（变基） git rebase 分支 记录图形展示 git log --graph --pretty=format:&quot;%h %s&quot; 2.8 第六阶段：多人协同开发工作流 2.8.1 创建项目&amp;邀请成员协同开发时，需要所有成员都可以对同一个项目进行操作，需要邀请成员并赋予权限，否则无法开发。github支持两种创建项目的方式（供多人协同开发）。 合作者，将用户添加到仓库合作者中之后，该用户就可以向当前仓库提交代码。 组织，将成员邀请进入组织，组织下可以创建多个仓库，组织成员可以向组织下仓库提交代码。 扩展：Tag标签管理为了能清晰的管理版本，在公司不会直接使用commit来做版本，会基于Tag来实现：v1.0 、 v1.2 、v2.0 版本。 git tag -a v1.0 -m &#x27;版本介绍&#x27; 创建本地创建Tag信息git tag -d v1.0 删除Taggit push origin --tags 将本地tag信息推送到远程仓库git pull origin --tags 更新本地tag版本信息git checkout v.10 切换taggit clone -b v0.1 地址 指定tag下载代码 2.8.2 小弟开发 小弟注册Github 或 Gitlab账号 邀请小弟进入组织（默认对组织中的项目具有读权限） 邀请小弟成为某项目的合作者 小弟在自己电脑上下载代码并开发 git clone https://github.com/oldboy-org/dbhot.gitcd dbhotgit checkout devgit checkout -b dzz 写代码...git add .git commit -m &#x27;斗地主功能开发完成&#x27;git push origin ddz 2.8.3 code review 配置，代码review之后才能合并到dev分支。 小弟提交 code review申请 组长做 code review 2.8.4 提测上线（预发布）由专门团队或团队leader执行以下步骤： 基于dev分值创建release分值 git checkout devgit checkout -b release 测试等 合并到master 使用pull request或本地将release合并到master分支 在master分支打tag git tag -a v2 -m &#x27;第二版 斗地主功能&#x27;git push origin --tags 运维人员就可以去下载代码做上线了 git clone -b v2 地址 2.9 第七阶段：给开源软件贡献代码 fork源代码将别人源代码拷贝到我自己的远程仓库。 在自己仓库进行修改代码 给源代码的作者提交 修复bug的申请（pull request） 第三章 其他3.1 配置 项目配置文件：项目&#x2F;.git&#x2F;config git config --local user.name &#x27;武沛齐&#x27;git config --local user.email &#x27;wupeiqi@xx.com&#x27; 全局配置文件: ~&#x2F;.gitconfig git config --global user.name &#x27;wupeiq&#x27;git config --global user.name &#x27;wupeiqi@xx.com&#x27; 系统配置文件：&#x2F;etc&#x2F;.gitconfig git config --system user.name &#x27;wupeiq&#x27;git config --system user.name &#x27;wupeiqi@xx.com&#x27;注意：需要有root权限 应用场景： git config --local user.name &#x27;武沛齐&#x27;git config --local user.email &#x27;wupeiqi@xx.com&#x27;git config --local merge.tool bc3git config --local mergetool.path &#x27;/usr/local/bin/bcomp&#x27;git config --local mergetool.keepBackup falsegit remote add origin 地址 ，默认添加在本地配置文件中(--local) 3.2 免密码登录 URL中体现 原来的地址：https://github.com/WuPeiqi/dbhot.git修改的地址：https://用户名:密码@github.com/WuPeiqi/dbhot.gitgit remote add origin https://用户名:密码@github.com/WuPeiqi/dbhot.gitgit push origin master SSH实现 1. 生成公钥和私钥(默认放在 ~/.ssh目录下，id_rsa.pub公钥、id_rsa私钥） ssh-keygen2. 拷贝公钥的内容，并设置到github中。3. 在git本地中配置ssh地址 git remote add origin git@github.com:WuPeiqi/dbhot.git 4. 以后使用 git push origin master git自动管理凭证 3.3 git忽略文件让Git不再管理当前目录下的某些文件。 *.h!a.hfiles/*.py[c|a|d] 更多参考：https://github.com/github/gitignore 3.4 github任务管理相关 issues，文档以及任务管理。 wiki，项目文档。 结课感谢各位同学的关注和学习，希望git实战课程对你能够有所帮助，更多资源关注： 小猿圈 &lt;www.apeland.cn&gt; 路飞学城 &lt;www.luffycity.com&gt; 老男孩IT教育 &lt;www.oldboyedu.com&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","permalink":"https://wendy-ljw.github.io/tags/git/"}]},{"title":"原型与原型链","slug":"js-prototype","date":"2022-11-14T09:44:36.000Z","updated":"2022-11-15T12:44:39.251Z","comments":true,"path":"2022/11/14/js-prototype/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/14/js-prototype/","excerpt":"","text":"原型与原型链原型：被用于复制现有实例来生成新实例的函数 原型链：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。 构造函数：用new来调用，就是为了创建一个自定义类，构造函数和普通函数本质上没什么区别，只不过使用了new关键字创建对象的函数，被叫做了构造函数。 实例：是类在实例化之后一个一个具体的对象 原型JS中每一个函数都有一个prototype属性，这个属性指向函数的原型对象，每一个由原型对象派生的子对象，都有相同的属性。子对象就叫构造函数，从实例原型中获取相同的属性。 我们所创建的每一格函数，解析器都会向函数中添加一个属性prototype这个属性对应着一个对象，这个对象就是我们所谓的原型对象 打比方说： function Person(age) &#123; this.age = age &#125;Person.prototype.name = &#x27;ljw&#x27;var person1 = new Person()var person2 = new Person()console.log(person1.name) //ljwconsole.log(person2.name) //ljw 其中，函数的prototype指向了一个对象，而这个对象正是调用构造函数时创建的实例的原型，也就是person1和person2的原型。 _Proto __Proto _是每一个子对象（除null外）都会有的一个属性，指向该对象的原型 当函数以构造函数的形式调用时，它所创造的对象中都会有一个隐含的属性指向该构造函数的原型对象，我们可以通过_proto_来访问属性 function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 此属性可以访问原型，但并不存在于Person.prototype中，来自于Object.prototype,类似getter&#x2F;setter，即使用obj._proto_时，可以理解为返回Object.getPrototypeOf(obj) 构造函数constructor每个原型都有一个constructor属性，指向该关联的构造函数 如果函数作为普通函数调用prototype没有任何作用 function Person() &#123;&#125;console.log(Person===Person.prototype.constructor) //true function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层(也就是Object)为止。 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中 function Person() &#123;&#125;Person.prototype.name = &#x27;Kevin&#x27;;var person = new Person();person.name = &#x27;Daisy&#x27;;console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.proto ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 原型链原型对象也是对象，所以它也有原型，当我们使用一个对象的属性或方法时，会按照以下步骤： 先在自身中寻找 自身中如果有，则直接使用 如果自身中没有则去原型对象中寻找，如果原型对象中有，则使用 如果原型对象中没有，则去原型对象的原型对象中寻找，直到找到Object对象的原型 Object有原型，但Object的原型没有原型，如果在Object的原型里没有找到，则返回undefined 整个查找过程都是顺着__proto__属性，一步一步往上查找，形成了像链条一样的结构，这个结构，就是原型链。所以，原型链也叫作隐式原型链。 检查属性函数 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回trueconsole.log(&quot;name&quot; in person) //true 使用对象的hasOwnProperty()来检查对象自身中是否含有该属性，只有当对象自身中含有属性时，才会返回trueconsole.log(&quot;person.hasOwnProperty()&quot;) //false","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"}]},{"title":"Markdown使用指南","slug":"markdown","date":"2022-11-11T01:12:03.000Z","updated":"2022-11-15T12:44:59.085Z","comments":true,"path":"2022/11/11/markdown/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/11/markdown/","excerpt":"我的第一篇博客，从刚学来的markdown开始","text":"我的第一篇博客，从刚学来的markdown开始 标题1.分级标题&#x3D;&#x3D;&#x3D;&#x3D;上面一行的内容就是一级标题—-上面一行的内容就是二级标题&#x3D;&#x3D;&#x3D;&#x3D;或—-都要单独一行 这是一个一级标题============================这是一个二级标题---------------------------- 第二种写法用#放标题最前面，几个#表示是几级标题 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 2.斜体和粗体代码 *斜体*或_斜体_**粗体*****加粗斜体***~~删除线~~ 显示效果 这是一段斜体 这是一段粗体 这是一段加粗斜体 这是一段删除线 3.超链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 3.1 行内式 [链接名](链接地址 “链接的title属性”)链接的title属性可以不加 欢迎来到[重庆理工大学](https://www.cqut.edu.cn/)欢迎来到[重庆理工大学](https://www.cqut.edu.cn/ &quot;重庆理工大学&quot;) 显示效果 欢迎来到重庆理工大学 欢迎来到重庆理工大学 3.2 参考式 利用变量的形式&#x2F;[链接名][链接变量名] 一般用在学术论文上 当某个链接在文章中多处使用的时候，也可以使用参考式超链接，会很方便 比如说[CQUT][1]、[Google][g][1]:https://www.cqut.edu.cn &quot;CQUT&quot;[g]:http://www.google.com &quot;Google&quot; 显示效果 比如说CQUT、Google 3.3 自动连接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。 &lt;https://www.cqut.edu.cn/&gt; 显示效果 https://www.cqut.edu.cn/ 4.列表4.1 无序列表使用 *，+，- 表示无序列表。 - 哈哈- 嘿嘿- 嘻嘻 显示效果 哈哈 嘿嘿 嘻嘻 4.2 有序列表有序列表则使用数字接着一个英文句点。 1. 嘿嘿2. 哈哈3. 嘻嘻 显示效果 嘿嘿 哈哈 嘻嘻 4.3 列表缩进- 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！- 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 4.4 包含段落的列表* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ * 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 4.5 列表嵌套* 无序1 1. 有序1 2. 有序2 - 无序3 3. 有序3* 无序2 - 无序4 显示效果 无序1 有序1 有序2 无序3 有序3 无序2 无序4 5.区块引用&gt;这是一个区块引用 显示效果 这是一个区块引用 还可嵌套引用 5.1 嵌套列表&gt;- 嵌套无序列表&gt;- haha&gt;1. 嵌套有序列表&gt;2.xixi 显示效果 嵌套无序列表 haha 嵌套有序列表 xixi 5.2 嵌套代码&gt;代码&gt;&gt; return 0; 显示效果 代码 return 0; 6.图像与超链接用法相似 6.1 行内式![花花](http://xtzl.wentexl.cn/ljw/bjt/b0002.jpg) 显示效果 6.2 参考式![花花][f][f]:http://xtzl.wentexl.cn/ljw/bjt/b0002.jpg &quot;花花&quot; 显示效果 7.注脚在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。[^1]:Markdown是一种纯文本标记语言[^2]:HyperTextMarkupLanguage超文本标记语言[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文 显示效果 使用 Markdown^1可以效率的书写文档, 直接转换成 HTML^2, 你可以使用 Leanote^Le 编辑器进行书写。 8.引用公式$表示行内公式 $$表示整行公式 一元二次方程$y=ax^2+bx+c$ 显示效果 一元二次方程$y&#x3D;ax^2+bx+c$ $$y=ax^2+bx+c$$$$x=x+1$$ 显示效果$$y&#x3D;ax^2+bx+c$$$$x&#x3D;x+1$$ 9.表格 不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。普通格式|表头|表头||-|-||1|单元格||2|表格|简单格式|表头|表头|-|-|1|单元格||2|表格|对齐|左对齐|右对齐|居中对齐|:-|-:|:-:|1|单元格|表格||2|表格|单元格| 显示效果 普通格式 表头 表头 1 单元格 2 表格 简单格式 表头 表头 1 单元格 2 表格 对齐 左对齐 右对齐 居中对齐 1 单元格 表格 2 表格 单元格 10.分隔线用三个及以上的*-_以及空格组成，显示效果都一样 **** * ******- - ----------- 显示效果 11.代码对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”&#96;”符号（一般在ESC键下方）包裹代码。 11.1 行内式记得`return 0` 显示效果 记得return 0 11.2 多行代码利用缩进或者是用&#96;&#96;&#96;&#96;&#96;&#96;包裹代码 #include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;Hello world\\n&quot;);&#125; 显示效果 #include &lt;stdio.h&gt; int main(void) &#123; printf(&quot;Hello world\\n&quot;); &#125; 11.3 直接引用HTML&lt;div&gt;这是一个块&lt;/div&gt; 显示效果 这是一个块 11.4 转义引用可以用反斜杠打印特殊符号，如： \\ 反斜线` 反引号* 星号_ 下划线&#123;&#125; 花括号[] 方括号() 小括号# 井字号+ 加号- 减号. 英文句点! 感叹号","categories":[{"name":"总结","slug":"总结","permalink":"https://wendy-ljw.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://wendy-ljw.github.io/tags/markdown/"}]},{"title":"文章演示页面","slug":"post-example","date":"2021-07-24T16:00:00.000Z","updated":"2022-11-15T12:46:09.348Z","comments":true,"path":"2021/07/25/post-example/","link":"","permalink":"https://wendy-ljw.github.io/2021/07/25/post-example/","excerpt":"显示在首页的内容","text":"显示在首页的内容 一级标题二级标题三级标题四级标题瀑布流图片 相片集 字符效果和横线等 删除线斜体字 斜体字粗体 粗体粗斜体 粗斜体 上标：X2，下标：O2 缩写(同HTML的abbr标签) 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启 The HTML specification is maintained by the W3C. 引用 Blockquotes 引用文本 Blockquotes 锚点与链接 Links普通链接 普通链接带描述 直接链接：https://github.com 多语言代码高亮 Codes行内代码 Inline code执行命令：npm install marked JS代码function test()&#123; console.log(&quot;Hello world!&quot;);&#125; (function()&#123; var box = function()&#123; return box.fn.init(); &#125;; box.prototype = box.fn = &#123; init : function()&#123; console.log(&#x27;box.init()&#x27;); return this; &#125;, add : function(str)&#123; alert(&quot;add&quot;, str); return this; &#125;, remove : function(str)&#123; alert(&quot;remove&quot;, str); return this; &#125; &#125;; box.fn.init.prototype = box.fn; window.box =box;&#125;)();var testBox = box();testBox.add(&quot;jQuery&quot;).remove(&quot;jQuery&quot;); HTML代码 HTML codes&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest=&quot;utf-8&quot; /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello world!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 图片 Images 图片加链接 (Image + Link)： 列表 Lists无序列表 列表一 列表二 列表二-1 列表二-2 列表二-3 列表三 列表一 列表二 列表三 有序列表 第一行 第二行 第三行 GFM task list GFM task list 1 GFM task list 2 GFM task list 3 GFM task list 3-1 GFM task list 3-2 GFM task list 3-3 GFM task list 4 GFM task list 4-1 GFM task list 4-2 绘制表格 Tables 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234","categories":[{"name":"种类","slug":"种类","permalink":"https://wendy-ljw.github.io/categories/%E7%A7%8D%E7%B1%BB/"}],"tags":[{"name":"标签","slug":"标签","permalink":"https://wendy-ljw.github.io/tags/%E6%A0%87%E7%AD%BE/"}]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"总结","slug":"总结","permalink":"https://wendy-ljw.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"种类","slug":"种类","permalink":"https://wendy-ljw.github.io/categories/%E7%A7%8D%E7%B1%BB/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://wendy-ljw.github.io/tags/es6/"},{"name":"git","slug":"git","permalink":"https://wendy-ljw.github.io/tags/git/"},{"name":"markdown","slug":"markdown","permalink":"https://wendy-ljw.github.io/tags/markdown/"},{"name":"标签","slug":"标签","permalink":"https://wendy-ljw.github.io/tags/%E6%A0%87%E7%AD%BE/"}]}