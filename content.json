{"meta":{"title":"Wendy","subtitle":"","description":"","author":"Wendy","url":"https://wendy-ljw.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-11-15T12:46:33.299Z","updated":"2022-11-15T12:46:33.299Z","comments":true,"path":"about.html","permalink":"https://wendy-ljw.github.io/about.html","excerpt":"","text":"今天我终于把我的博客搭建成功了"},{"title":"朋友","date":"2022-11-15T12:46:38.231Z","updated":"2022-11-15T12:46:38.231Z","comments":true,"path":"PY.html","permalink":"https://wendy-ljw.github.io/PY.html","excerpt":"","text":"戳这可见文特的博客"},{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2022-11-10T11:04:24.717Z","comments":true,"path":"page/index.html","permalink":"https://wendy-ljw.github.io/page/index.html","excerpt":"","text":"This is a page test."},{"title":"文章归档","date":"2022-11-10T11:15:45.811Z","updated":"2022-11-10T11:15:45.811Z","comments":true,"path":"archive.html","permalink":"https://wendy-ljw.github.io/archive.html","excerpt":"","text":""}],"posts":[{"title":"总结","slug":"sum-1","date":"2023-03-17T11:31:36.000Z","updated":"2023-05-08T14:39:20.335Z","comments":true,"path":"2023/03/17/sum-1/","link":"","permalink":"https://wendy-ljw.github.io/2023/03/17/sum-1/","excerpt":"","text":"面试总结HTMLCSSCSS盒模型以及有哪几种标准盒模型（content-box）： height&#x3D;content (浏览器默认) IE盒模型（border-box）：height&#x3D;content+padding+border 盒模型的种类通过box-sizing设置，如 box-sizing:border:box flex:1flex: 1是CSS中用于布局的一个属性，它的作用是指定元素在弹性布局中的伸缩比例。当一个容器中有多个子元素时，可以通过flex属性来控制它们在容器中的占比。 具体来说，flex属性是一个简写属性，包括了flex-grow、flex-shrink和flex-basis三个属性。这三个属性分别代表了弹性容器中的三个伸缩属性： flex-grow属性表示元素的放大比例，默认值为0，即不放大。 flex-shrink属性表示元素的缩小比例，默认值为1，即按比例缩小。 flex-basis属性表示元素在分配多余空间之前的基准大小，默认值为auto，即根据元素的实际大小来分配空间。 当使用flex:1时，实际上是将flex-grow属性设置为1，其它属性保持默认值。这样，所有具有flex:1样式的子元素都将按照相同的比例来分配容器中的剩余空间，使它们占据相等的空间。 需要注意的是，如果弹性容器中有多个子元素，且它们的flex属性不同，那么它们将按照flex属性的大小来分配空间。如果一个元素的flex属性值为2，而另一个元素的flex属性值为1，则前者占用的空间是后者的两倍。 总之，使用flex:1可以很方便地实现等比例的布局效果，特别是在响应式布局中，可以避免写复杂的媒体查询和计算百分比宽度的麻烦。 画一条0.5px的线transform:scaleY(0.5)+transfom-origin:50% 100% 内联样式与样式表的区别内联样式和样式表都是用于设置网页样式的方法，它们的区别在于： 内联样式是直接在HTML元素中设置样式，而样式表是在HTML文档中引用的外部样式文件。 内联样式的优先级比样式表高，即如果同时设置了相同的样式属性，内联样式会覆盖样式表中的设置。 样式表可以应用于多个HTML元素，而内联样式只能应用于单个元素。 样式表可以通过媒体查询设置响应式样式，而内联样式不能。 综上所述，虽然内联样式和样式表都可以用于设置网页样式，但样式表更加灵活、可维护性更好，适用于大规模的网站开发。而内联样式则适用于少量样式的个别元素设置。 内联样式的优先级更高，是在标签中的属性中添加 样式表是写在style标签中用的 如何实现水平垂直居中 可以用table形式实现（display:table） 可以用弹性盒子的方式（display:flex）推荐 justify-content: center; align-items: center; 网格布局（display:grid） align-self: center; justify-self: center; Javascriptjs性能的优化 减少DOM操作：DOM操作是一项非常消耗性能的操作，因此应该尽可能减少DOM操作次数。可以考虑使用innerHTML代替大量的DOM操作，或者使用文档片段（DocumentFragment）等技术来减少DOM操作次数。 123456常见的DOM操作包括：获取元素：通过getElementById、getElementsByTagName、getElementsByClassName等方法获取页面元素。修改元素属性：通过setAttribute、removeAttribute、className等方法修改元素属性。修改元素内容：通过innerHTML、textContent等属性或者innerText、appendChild等方法修改元素内容。添加元素：通过createElement、createTextNode、appendChild等方法添加新的元素。删除元素：通过removeChild等方法删除元素。 避免全局变量：在JavaScript中，全局变量的访问比局部变量的访问要慢得多，因此应该尽可能避免使用全局变量。可以使用闭包或模块模式等技术来封装变量，或者使用ES6中的let和const来声明变量。 避免重复计算：在一些复杂的算法中，重复计算可能会导致性能问题。可以将计算结果缓存起来，避免重复计算。例如，可以将某个函数的计算结果缓存到对象中，下次调用时直接从缓存中获取结果。 使用事件委托：事件委托是一种优化性能的常见方法。它通过将事件处理程序绑定到父元素上，而不是绑定到每个子元素上，从而减少了事件处理程序的数量。这样可以减少内存占用和提高性能。 使用异步加载：异步加载可以提高页面的加载速度，从而提高性能。可以使用异步加载技术来加载JavaScript文件、CSS文件等资源。 使用缓存：JavaScript代码可以被缓存到客户端，从而减少服务器负载和提高性能。可以使用HTTP缓存、本地存储等技术来缓存JavaScript代码。 代码优化：JavaScript代码的优化可以提高代码的执行效率和性能。例如，可以尽可能使用简单的算法，避免过多的循环嵌套等。 总的来说，JavaScript性能的优化是一个复杂的过程，需要在实际项目中根据具体情况进行调优。以上是一些常见的优化方法，可以作为参考。 Js跨域的定义当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。 this的作用 全局代码中的this是指向全局对象，在浏览器中是window 作为单纯的函数调用，在普通函数中的this，指向了全局函数，即window ，在严格模式下，是undefined 作为对象的方法调用，this指向当前对象 作为构造函数内部的this指向新创建的对象 内部函数1234567891011var name = &quot;clever coder&quot;; var person = &#123; name : &quot;foocoder&quot;, hello : function(sth)&#123; var sayhello = function(sth) &#123; console.log(this.name + &quot; says &quot; + sth); &#125;; sayhello(sth); &#125; &#125; person.hello(&quot;hello world&quot;);//clever coder says hello world 在内部函数中，this没有按预想的绑定到外层函数对象上，而是绑定到了全局对象。这里普遍被认为是JavaScript语言的设计错误，因为没有人想让内部函数中的this指向全局对象。一般的处理方式是将this作为变量保存下来，一般约定为that或者self：123456789101112var name = &quot;clever coder&quot;; var person = &#123; name : &quot;foocoder&quot;, hello : function(sth)&#123; var that = this; var sayhello = function(sth) &#123; console.log(that.name + &quot; says &quot; + sth); &#125;; sayhello(sth); &#125; &#125; person.hello(&quot;hello world&quot;);//foocoder says hello world js实现继承的方式事件捕获与事件冒泡事件冒泡是由里到外，向上层延申；事件捕获是由外到里，前往捕获，形成向下趋势。 图片懒加载如何实现？ img元素的自定义属性上data-xxx上挂载目标图片url, src属性指向默认图片地址。 监听图片是否出现在用户的可视区域内。 出现在可视区域内后更新src属性为目标图片url。 js实现代理和事件冒泡的区别 事件代理：把原本需要绑定在子元素上的事件（onclick、onkeydown 等）委托给它的父元素，让父元素来监听子元素的冒泡事件，并在子元素发生事件冒泡时找到这个子元素。 事件冒泡： 当一个子元素的事件被触发的时候（如onclick事件），该事件会从事件源（被点击的子元素）开始逐级向上传播，触发父级元素的点击事件。 防抖节流的区别防抖(debounce): 所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 节流(throttle): 所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。 防抖：在单位时间内频繁触发事件，只有最后一次生效节流：在单位时间内频繁触发事件，只生效一次（也就是只有第一次生效） 相同点1.都可以通过使用 setTimeout 来实现2.都可以降低回调执行频率，节省计算资源 闭包 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。 闭包的特点 让外部访问函数内部变量变成可能 变量会常驻在内存中 可以避免使用全局变量防止全局变量污染 好处：可以读取其他函数内部的变量，并将其一直保存在内存中。 坏处：可能会造成内存泄漏或溢出 两个常见用途： 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。 点击事件代理的几种方式var dom &#x3D; document.getElementByClasses(“first”); dom[0].onclick &#x3D; function(){alert(111);}; dom[0].onclick &#x3D; function(){alert(222);}; 这里千万注意！！！这种做法只能绑定一个事件处理函数，后面的会覆盖前面的。比如这里只会输出222，这只是其中一种 还有写了监听器和两个内联的。 监听器的三个参数代表了什么含义第一个参数是事件类型，比如点击(click)、双击(dbclick) 第二个参数就是函数，触发事件后，需要执行的函数。 第三个参数就是事件的捕获与冒泡， 为true时捕获，false时冒泡。 ES6原型与原型链每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。 属性constructor指回构造函数本身 属性 proto 指向构造函数的prototype 原型对象 HTTPHttp协议的方法有哪些 GET：请求指定的页面信息，并返回实体主体。 HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。 PUT：从客户端向服务器传送的数据取代指定的文档的内容。 DELETE：请求服务器删除指定的页面。 CONNECT：HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS：允许客户端查看服务器的性能。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 状态码301 永久性重定向，表示请求的资源已被分配了新的 URI302 临时性重定向，资源的 URL 已临时定位到其他位置 OSI七层Vuevue2.0 与 vue3.0 数据双向绑定的区别vue2.x实现双向数据绑定的原理是利用Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的，当数据发生改变发出通知。在MDN上对该方法的说明是：Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。它接收三个参数，要操作的对象，要定义或修改的对象属性名，属性描述符。重点就是最后的属性描述符。属性描述符是一个对象，主要有两种形式：数据描述符和存取描述符。这两种对象只能选择一种使用，不能混合两种描述符的属性同时使用。上面说的 get 和 set 就是属于存取描述符对象的属性。然后我们可以通过在存取描述符中的get和set方法内写入自定义的逻辑来实现对象获取属性和设置属性时的行为。 相比于vue2.x，vue3.0使用proxy的优势如下区别： 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可） vue3.x可以监听到数组内部数据的变化，不用再去单独的对数组做特异性操作 proxy可以劫持整个对象，并返回一个新对象 Vue2.x版本中的双向绑定不能检测到下标的变化 defineProperty只能监听某个属性，不能对全对象监听 vue生命周期以及每个大概的概述 beforeCreate:在实例初始化之后，数据观测 (data observer) 和 event&#x2F;watcher 事件配置之前被调用。在new一个vue实例后，只有一些默认的生命周期钩子和默认事件，其他的东西都还没创建。在beforeCreate生命周期执行的时候，data和methods中的数据都还没有初始化。不能在这个阶段使用data中的数据和methods中的方法 created:在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (dataobserver)，roperty 和方法的运算，watch&#x2F;event 事件回调。然而，挂载阶段还没开始，$el property 目前尚不可用。data 和 methods都已经被初始化好了，如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作 beforeMount:在挂载开始之前被调用：相关的 render 函数首次被调用。执行到这个钩子的时候，在内存中已经编译好了模板了，但是还没有挂载到页面中，此时，页面还是旧的 mounted:实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。执行到这个钩子的时候，就表示Vue实例已经初始化完成了。此时组件脱离了创建阶段，进入到了运行阶段。如果我们想要通过插件操作页面上的DOM节点，最早可以在这个阶段中进行 beforeUpdate:当执行这个钩子时，页面中的显示的数据还是旧的，data中的数据是更新后的， 页面还没有和最新的数据保持同步 updated:页面显示的数据和data中的数据已经保持同步了，都是最新的 beforeDestroy:Vue实例从运行阶段进入到了销毁阶段，这个时候上所有的 data 和 methods，指令，过滤器……都是处于可用状态，还没有真正被销毁 destroyed:这个时候上所有的 data 和 methods，指令，过滤器……都是处于不可用状态，组件已经被销毁了。 activated:被 keep-alive 缓存的组件激活时调用。 deactivated:被 keep-alive 缓存的组件停用时调用。 vue3核心原理响应式系统：Vue 3使用了Proxy代理实现了更高效的响应式系统。当数据发生变化时，会自动触发视图的更新。这个特性使得Vue 3的性能比Vue 2更高效，且在处理大型应用程序时表现更加出色。 组合式API：Vue 3提供了新的组合式API，使得开发者可以更好地组织和复用代码逻辑。通过这个API，我们可以将逻辑代码按功能划分为多个逻辑单元，然后可以将它们组合在一起使用，从而提高代码的可读性和可维护性。 Teleport组件：Vue 3的Teleport组件可以在DOM层级中移动任意组件或元素，从而使得开发者可以更灵活地进行页面布局。 Composition API：Vue 3的Composition API提供了更为灵活和可组合的功能，能够更好地与TypeScript等其他工具和库配合使用。 性能优化：Vue 3在性能上做出了很多优化，例如将虚拟DOM的生成和比较算法进行了优化，使得页面渲染更加高效。同时，Vue 3还通过Tree Shaking等技术，使得打包后的代码更加轻量级。 总的来说，Vue 3的核心原理在于响应式系统、组合式API和性能优化等方面的创新，使得Vue 3在开发效率、代码可维护性和性能等方面都有很大的提升。 watch和computed的区别，异步操作选哪个？ computed支持缓存，只有依赖数据发生改变，才会重新进行计算;而watch不支持缓存，数据变，直接会触发相应的操作。 computed不支持异步，当computed内有异步操作时无效，无法监听数据的变化;watch支持异步。 computed属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值;而watch监听的函数接收两个参数，第一个参数是最新的值，第二个参数是输入之前的值。 如果一个属性是由其它属性计算而来的，这个属性依赖其它属性，是一个多对一或者一对一，一般用computed;而当一个属性发生变化时，需要执行对应的操作;一对多一般用watch。 如果computed属性属性值是函数，那么默认会走get方法;函数的返回值就是属性的属性值;在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。而watch监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其它操作，函数有两个参数。 vue组件之间的通信ref被用来给元素或子组件注册引用信息，引用信息将会注册在父组件的$refs对象上，如果是在普通的DOM 元素上使用，引用指向的就是DOM 元素，如果是在子组件上，引用就指向组件的实例。 ‘$refs’是一个对象，持有已注册过ref的所有的子组件。 ref有三种用法： ref加在普通的元素上，用this.$refs.name获取到的是dom元素 ref加在子组件上，用this.$refs.name获取到的是组件实例，可以使用组件的所有方法。 利用v-for和ref获取一组数组或者dom节点。 注意： ref需要在dom渲染完成后才会有，在使用的时候确保dom已经渲染完成。比如在生命周期mounted(){}钩子中调用，或者在this.$nextTick(()&#x3D;&gt;{})中调用。 如果ref是循环出来的，有多个重名，那么ref的值会是一个数组，此时要拿到单个的ref只需要循环就可以了。 vue由什么可以优化的地方 使用Vue.js的编译器来预编译Vue组件，以提高渲染速度。 尽可能使用v-if代替v-show来避免在组件之间切换时重复渲染DOM元素。 使用v-bind来动态地绑定属性和class，避免在DOM元素之间切换时重复渲染。 避免在v-for循环中使用复杂的计算属性，尽可能将计算属性转移到数据中，以提高渲染速度。 使用Vue.js的keep-alive组件来缓存已渲染的组件，以便在切换时快速重用。 尽可能使用异步组件加载和懒加载来减少初始加载时间。 对于大型应用程序，使用Vue.js的路由懒加载来延迟加载路由组件，以提高初始加载时间。 避免频繁的操作DOM，尽可能使用Vue.js提供的指令和组件来处理DOM操作。 使用Vue.js提供的响应式数据绑定来避免手动处理DOM事件和状态更新。 对于需要大量数据的列表，使用Vue.js的虚拟滚动组件来提高性能并避免卡顿。总的来说，优化Vue.js应用程序的最佳方法是避免不必要的DOM操作，减少网络请求和数据处理，并最大限度地利用Vue.js提供的优化工具和组件。 vue数据更新后的底层逻辑vue3的优化 在main.js中引入的不再是Vue构造函数，而是一个名为creatApp的工厂函数（不用通过new调用） 创建实例对象方式不同，Vue2是用vm来创建对象，Vue3是用app来创建 在main.js中不兼容Vue2的写法 在Vue3的模板结构可以没有根标签，template中可以直接包其他标签 Composition API 组合式API setup是Vue3.0中一个新的配置项是个函数，所有数据方法都是setup中，用setup代替了data,methods,钩子等，当Vue2与Vue3混用时Vue3优先 在setup中return需要返回数据 需要引入ref来实现响应式数据，但是，如果引用的是ref函数，在调用变量时需要加.value 因此可以使用reactive函数来实现，但是reactive函数不能给基本类型使用，会报错；当对象类型的数据调用后，引用数据就不再需要加.value，可以直接调 reactive函数嵌套使用也很方便 可以直接索引修改数组的数据 会接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象） 内部基于ES6的Proxy实现，通过代理对象操作源对象内部数据进行操作 Vue2响应式存在的问题在Vue3被解决了 进行新增属性、删除属性等操作时，数据改变了却没有被Vue2捕获，因此界面也不会发生变化 直接通过下边修改数组，界面不会自动更新 Vue3用到了Proxy代理，Reflect反射 通过Proxy（代理）拦截对象中任意属性的变化 通过Reflect（反射）对被代理对象的属性进行操作 Vue3的watch在监视reactive所定义的一个响应式数据没有oldValue，并且强制开启了深度监视，所以此时deep配置无效，但是如果是监视该数据中的某个属性时，deep配置奏效。 watchEffect监视，立即执行，想监视啥，就在里面写啥，和computed有点像，但是computed有返回值。 生命周期不同。 hook函数，可以将同个功能的相关函数、钩子、数据包在一个js中，方便后续调用，整洁美观不凌乱 provide inject实现祖先与后代组件通信 浏览器浏览器的本地缓存方式localStorage，sessionStorage，cookie 的区别 cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器来回传递 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存 存储大小限制也不同 cookie数据不能超过4k sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以到5M(这个大小也问到了)或更大 数据有效期不同 sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持； localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭; 作用域不同 sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面； localStorage 在所有同源窗口中都是共享的； cookie也是在所有同源窗口中都是共享的 垃圾回收机制普通刷新与强制刷新缓存相关知识保持数据不变如果我打开了页面A，又打开了页面B，此时我从页面B返回了页面A，如何实现页面A的数据还是我离开页面A时的数据？ 使用浏览器的缓存机制：当用户从页面 A 跳转到页面 B 时，可以将页面 A 的数据存储到浏览器的缓存中。当用户从页面 B 返回页面 A 时，可以先检查缓存中是否存在页面 A 的数据，如果存在则直接从缓存中读取数据渲染页面，否则重新加载页面并获取数据。当使用浏览器的缓存机制来实现页面数据的持久化时，可以使用以下步骤： 在页面 A 中将需要持久化的数据存储到浏览器的缓存中。可以使用 localStorage 或 sessionStorage 对象来进行存储。这些对象提供了键值对的存储方式，并且可以存储字符串类型的数据。例如，在页面 A 中可以使用以下代码将数据存储到 localStorage 中： localStorage.setItem(‘data’, JSON.stringify(data)); 其中，data 是需要存储的数据对象，JSON.stringify 函数用于将对象转换为字符串。 当用户从页面 B 返回页面 A 时，可以检查缓存中是否存在页面 A 的数据。可以使用 localStorage 或 sessionStorage 对象的 getItem 方法来获取存储在缓存中的数据。例如，在页面 A 中可以使用以下代码检查缓存中是否存在数据： 12345678const data = localStorage.getItem(&#x27;data&#x27;);if (data) &#123; // 缓存中存在数据，将数据解析为对象并渲染页面 render(JSON.parse(data));&#125; else &#123; // 缓存中不存在数据，重新加载页面并获取数据 loadData();&#125; 当用户再次离开页面 A 时，可以将数据从缓存中删除，以避免缓存过多无用数据占用浏览器的存储空间。可以使用 localStorage 或 sessionStorage 对象的 removeItem 方法来删除缓存中的数据。例如，在页面 A 中可以使用以下代码删除缓存中的数据： localStorage.removeItem(‘data’); 使用浏览器的缓存机制来实现页面数据的持久化需要注意以下几点： 缓存中存储的数据必须是字符串类型，因此需要将对象序列化为字符串或从字符串中解析为对象。 缓存中的数据可能会被清除或过期，因此在获取数据时需要先检查数据是否存在，如果不存在则需要重新加载页面并获取数据。 缓存中存储的数据会占用浏览器的存储空间，因此需要注意清理无用的数据以避免浏览器存储空间的浪费。 数据结构数组去重用哪些方法 利用Set()+Array.from() 利用两层循环+数组的splice方法 利用数组的indexOf方法 利用数组的includes方法 利用数组的filter()+indexOf() 堆栈和队列的区别其他你有了解过webpack吗？Webpack是一个开源的前端构建工具，它可以将多个模块打包成一个或多个浏览器可识别的JavaScript文件。Webpack提供了一个灵活的插件系统，可以通过配置文件对其进行配置以满足各种不同的构建需求。 Webpack的主要功能包括： 模块化管理：Webpack可以将JavaScript代码拆分成多个模块，每个模块可以独立开发、测试和维护，然后通过Webpack打包成一个或多个JavaScript文件，使得代码的复用性和可维护性得到提升。 资源加载器：Webpack支持加载各种类型的文件，包括JavaScript、CSS、图片等，并提供了丰富的加载器，可以对各种类型的文件进行处理，例如使用babel-loader对ES6语法进行转换，使用css-loader和style-loader对CSS文件进行处理等。 代码分割：Webpack支持将代码拆分成多个包，并根据需要异步加载，从而实现按需加载和提高页面加载速度的目的。 插件系统：Webpack提供了丰富的插件系统，可以通过配置文件对其进行配置以满足各种不同的构建需求，例如压缩代码、提取公共代码、生成HTML模板等。 总的来说，Webpack可以帮助我们更方便、高效地管理和打包项目中的各种资源，提高项目的可维护性和性能。 git merge,git rebase的区别git merge 和 git rebase 都是 Git 版本控制系统中用于合并代码分支的命令，但是它们的实现方式不同。 git merge 命令会将两个不同的分支合并成一个新的分支。它会创建一个新的提交来整合两个分支的更改，并将这个新的提交添加到当前分支中。使用 git merge 时，需要先切换到要接收合并的分支，然后执行命令。 例如，假设当前在分支 A 上，要将分支 B 合并到分支 A 上： 12git checkout Agit merge B 这会将分支 B 中的更改合并到分支 A 中，并生成一个新的合并提交。 git rebase 命令的作用是将当前分支的提交基础转移到另一个分支上。这意味着 Git 会将当前分支的所有提交按照时间顺序依次应用到目标分支上，使得目标分支的历史记录变得更加线性。使用 git rebase 时，需要先切换到要接收变基的分支，然后执行命令。 例如，假设当前在分支 A 上，要将分支 A 变基到分支 B 上： 12git checkout Agit rebase B 这会将分支 A 上的提交基础转移到分支 B 上，并生成一个新的历史记录。请注意，由于重新应用提交，这可能会改变提交的哈希值，因此需要小心处理可能影响其他人协作的提交。 最主要的区别在于合并历史记录的方式不同。 git merge 命令将两个分支的历史记录合并成一个新的提交，并将该新提交添加到当前分支上，从而创建一个新的合并分支。这样做可以保留原始分支的历史记录，但会创建一个额外的合并提交，使得历史记录更加分叉。 git rebase 命令会将当前分支的历史记录“移动”到目标分支上，并重新应用每个提交。这样做可以使得历史记录更加线性，但会破坏原始分支的历史记录，因为提交的哈希值会发生变化。 总的来说，如果只是想简单地将两个分支合并，那么使用 git merge 更为直观和简单。但如果您想要保持一个线性的历史记录，或者需要在协作时避免创建额外的合并提交，那么使用 git rebase 更为合适。 npm和yarn的区别npm是一个包管理器，它让 javascript 开发者分享、复用代码更方便.在程序开发中我们常常需要依赖别人提供的框架，写js 也不例外。这些可以重复的框架代码被称作包(package)或者模块(module)，一个包可以是一个文件夹里放着几个文件，同时有一个叫做 package.json的文件。 npm（node package manager）：node.js 的包管理器，用于node插件管理（包括安装、卸载、管理依赖等） ，npm 是随同 node.js 一起安装的包管理工具，能解决 node.js 代码部署上的很多问题，常见的使用场景有以下几种：1.允许用户从 npm 服务器下载别人编写的第三方包到本地使用。允许用户从 npm 服务器下载并安装别人编写的命令行程序到本地使用。允许用户将自己编写的包或命令行程序上传到 npm 服务器供别人使用。 npm 的缺陷：npm install 下载速度慢，重新 install 时速度依旧慢。同一个项目，安装的无法保持一致性。原因是因为 package.json 文件中版本号的特点导致的，下面三个版本号在安装的时候代表不同的含义。“5.0.3” # 表示安装指定的5.0.3版本“~5.0.3” # 表示安装5.0.X中最新的版本“^5.0.3” # 表示安装5.X.X中最新的版本 使用 npm 安装多个 js 包时，包会在同一时间下载和安装。安装过程中，其中一个包抛出了一个异常，但 npm 会继续安装其他包，所以错误信息就会在一大堆提示信息中丢失掉，以至于直到执行前，都不会发现实际发生的错误。 yarn 是由 Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具，yarn 是为了弥补 npm 的一些缺陷而出现的。 Yarn 优点1.速度快 。速度快主要来自以下两个方面： 2.并行安装：无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务。npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。 3.离线模式：如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。 4.安装版本统一：为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。npm 其实也有办法实现处处使用相同版本的 packages，但需要开发者执行 npm shrinkwrap 命令。这个命令将会生成一个锁定文件，在执行 npm install 的时候，该锁定文件会先被读取，和 Yarn 读取 yarn.lock 文件一个道理。npm 和 Yarn 两者的不同之处在于，Yarn 默认会生成这样的锁定文件，而 npm 要通过 shrinkwrap 命令生成 npm-shrinkwrap.json 文件，只有当这个文件存在的时候，packages 版本信息才会被记录和更新。 5.更简洁的输出：npm 的输出信息比较冗长。在执行 npm install 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn 简洁太多：默认情况下，结合了 emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。 6.多注册来源处理：所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。 7.更好的语义化： yarn改变了一些npm命令的名称，比如 yarn add&#x2F;remove，感觉上比 npm 原本的 install&#x2F;uninstall 要更清晰。 你认为一个好的前端技术人员需要具备什么能力如何提升用户体验如何加快页面加载速度描述一下做的项目这个系统采用了前后端分离的模式，主要是通过使用使用后端给的接口来实现的，前端是使用了vue3.0的框架，界面是使用了element-ui组件。包含以下几个模块，登录注册页面，人员信息管理，核酸检测管理，疫苗信息管理，隔离信息管理等。其中使用vuex进行组件之间的状态管理，解决了多级组件之间传值困难的问题，然后利用vue-router实现了组件和渲染路径的映射切换。我实现的功能主要是将展现在页面上，并实现针对不同的管理员给予不同的权限，实现了对列表信息的增删改查以及分页展示功能，新增时刷新页面，编辑时传递当前的id展示编辑内容，然后form表单提交编辑信息，然后是首页，通过npm引入echarts，初始化一个echarts实例，将配置的option赋值给实例，在mounted确定dom加载完毕调用，对学生的各项信息进行可视化展示。 首先就是用了脚手架来初始化了整个项目，然后构思了二手商城的主要页面，分别是登录注册，首页，购物车页面，个人中心，商品详情页等，然后根据构思再来设计好路由，再新建各个组件，将各个页面的公用部分提取出来比如说header和footer是每个页面公用的，接下来就是element-ui搜罗合适的组件放入，然后用less语言来修改一下组件的样式，交的内容大部分就是在script里写方法，数据的交互的话就通过封装axios来实现，封装了一次之后，接下来再调用的话就会很方便使用","categories":[{"name":"总结","slug":"总结","permalink":"https://wendy-ljw.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"实习面试总结","slug":"interview-experience-1","date":"2023-02-08T00:59:03.000Z","updated":"2023-05-08T15:44:45.901Z","comments":true,"path":"2023/02/08/interview-experience-1/","link":"","permalink":"https://wendy-ljw.github.io/2023/02/08/interview-experience-1/","excerpt":"","text":"百度实习一面面试时间2023-2-7 CSS盒模型以及有哪几种 画一条0.5px的线 内联样式与样式表的区别 原型与原型链 每个原型都有个什么属性指向它的构造函数、关联对象 如何实现水平垂直居中 Js跨域的定义 this的作用 状态码301与302 js实现继承的方式 js实现代理和事件冒泡的区别 防抖节流的区别 浏览器的本地缓存方式 Http协议的方法有哪些 数组去重用哪些方法 垃圾回收机制 小米实习一面面试时间2023-2-16 算法题 1234567891011121314151617181920找不同题目描述给定两个字符串 s 和 t ，它们只包含小写字母。​字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。​请找出在 t 中被添加的字母。​示例 1：​输入：s = &quot;abcd&quot;, t = &quot;abcde&quot;​输出：&quot;e&quot;​解释：&#x27;e&#x27; 是那个被添加的字母。​示例 2：​输入：s = &quot;&quot;, t = &quot;y&quot;​输出：&quot;y&quot;​ ​提示：​1. 0 &lt;= s.length &lt;= 1000​2. t.length == s.length + 1​3. s 和 t 只包含小写字母 1234567891011121314151617181920212223242526272829import java.util.Scanner;public class Main &#123; public static char findDifference(String s, String t)&#123; int[] arr1 = new int[26]; int[] arr2 = new int[26]; char[] char1 = s.toCharArray(); char[] char2 = s.toCharArray(); int len1 = char1.length; int len2 = char2.length; for(int i=0;i&lt;len1;i++)&#123; arr1[char1[i] - &#x27;a&#x27;] +=1; &#125; for(int i=0;i&lt;len2;i++)&#123; arr2[char2[i] - &#x27;a&#x27;] +=1; &#125; for(int i = 0; i&lt;26;i++)&#123; if(arr1[i]!=arr2[i])&#123; return (char)(i+97); &#125; &#125; &#125; public static void main(String[] args)&#123; String s = &quot;abcd&quot;; String t =&quot;abcde&quot;; System.out.println(findDifference(s, t)); &#125;&#125; 闭包 防抖节流的区别以及具体的应用 flex布局 vue2.0 与 vue3.0 数据双向绑定的区别 let和var的区别 小米实习二面面试时间2023-2-27 算法题 给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处: 0 &lt;&#x3D; j &lt;&#x3D; nums[i]i + j &lt; n返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。 示例1： 输入：nums &#x3D; [2,3,1,1,4]输出：2 解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 123456789101112131415161718192021//这是网上搜到的解答，当时写的没来得及保存public static int jump(int []arr)&#123; int end = 0; int position = 0; int step = 0; for(int i=0;i&lt; arr.length-1;i++)&#123; //记录能够跳到最远位置 position = Math.max(position, i+arr[i]); //限制在每次跳最远的区间范围计算 //当i到达边界 if(i==end)&#123; //重新记录能够跳到最远处为新的区间边界 end=position; //步数加1 step++; &#125; &#125; //返回步数 return step;&#125; 第二题是一个CSS题 忘记截屏了，实现效果就是一个绿色圆矩形在左右两边的腰上都有两个小凹槽， 我用三个div来解决的，面试官问我一个div如何解决，我没打出来，原来可以用伪元素解决 第三个写的题是事件循环的输出 第四个写的题是让我写一下点击事件代理的几种方式 监听器的三个参数代表了什么含义 vue生命周期以及每个大概的概述 如果我打开了页面A，又打开了页面B，此时我从页面B返回了页面A，如何实现页面A的数据还是我离开页面A时的数据？ 防抖节流 你有了解过webpack吗？ watch和computed的区别，异步操作选哪个？ vue组件之间的通信，详细讲ref $parent $child 与 prop $emit 的区别 vue由什么可以优化的地方 git用过什么命令？git merge,git rebase什么意思？ npm和yarn的区别 一开始让我手写一个promise后来就问了我一些promise的问题 三个状态是什么？是否可逆？ 问我如何实现一个成功就成功，以及一个失败就失败 vue的组件化 美团面试一面 你认为一个好的前端技术人员需要具备什么能力 如何提升用户体验 如何加快页面加载速度 描述一下做的项目 图片懒加载如何实现？ vue数据更新后的底层逻辑 堆栈和队列的区别 OSI七层 缓存相关知识 普通刷新与强制刷新 事件捕获与事件冒泡 vue3的优化 进程与线程 亚信一面面试时间：2023-5-8 15：30-16：15 介绍项目 let const var 的区别 js对DOM的操作，如新建节点、删除节点等 数组的常见方法 项目对图片的处理 项目中遇到的难点 ES6新特性 箭头函数和普通函数的区别 computed和watch的区别","categories":[{"name":"面试","slug":"面试","permalink":"https://wendy-ljw.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://wendy-ljw.github.io/tags/es6/"},{"name":"css","slug":"css","permalink":"https://wendy-ljw.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://wendy-ljw.github.io/tags/html/"},{"name":"http","slug":"http","permalink":"https://wendy-ljw.github.io/tags/http/"}]},{"title":"消除开发者模式提示","slug":"vue-prob-2","date":"2023-01-07T13:12:46.000Z","updated":"2023-01-08T03:12:35.292Z","comments":true,"path":"2023/01/07/vue-prob-2/","link":"","permalink":"https://wendy-ljw.github.io/2023/01/07/vue-prob-2/","excerpt":"","text":"消除console提示消除开发者模式的提示，用处就是看着舒服点 方法：直接在sript中设置 123&lt;script type=&quot;text/javascript&quot; &gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。&lt;/script&gt; 不知道为什么这个方法对我没有用 因此直接点开vue.js修改源代码，我的在398行 1productionTip: false, 然后就成功了！","categories":[{"name":"杂疑","slug":"杂疑","permalink":"https://wendy-ljw.github.io/categories/%E6%9D%82%E7%96%91/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wendy-ljw.github.io/tags/vue/"}]},{"title":"hexo 博客维护的常用命令","slug":"hexo","date":"2023-01-04T12:26:42.000Z","updated":"2023-01-08T03:09:36.412Z","comments":true,"path":"2023/01/04/hexo/","link":"","permalink":"https://wendy-ljw.github.io/2023/01/04/hexo/","excerpt":"","text":"几个常见命令 在文件夹下打开git bash，然后输入命令 hexo clean 清除缓存 hexo server (hexo s) 在本地启动 hexo generate (hexo g) 生成静态网页 hexo deploy (hexo d) 部署到服务器上 hexo new hexo new post text 新建一篇博客 hexo new text 默认新建一篇博客 hexo new page newpage 另起一页 hexo new dradt newdraft 新建一篇草稿 hexo server –draft 预览草稿 hexo publish draft newdraft 将这篇草稿发布到post中","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","permalink":"https://wendy-ljw.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://wendy-ljw.github.io/tags/hexo/"}]},{"title":"deep深度选择器","slug":"vue-deep","date":"2023-01-04T12:26:15.000Z","updated":"2023-01-19T14:03:25.107Z","comments":true,"path":"2023/01/04/vue-deep/","link":"","permalink":"https://wendy-ljw.github.io/2023/01/04/vue-deep/","excerpt":"","text":"在写项目的过程中，用到了element-ui组件，但是组件都是蓝色的，而我的项目是以粉色为主题的，因此就需要用到了deep深度选择器来解决颜色问题 我主要变的就是输入框在focus状态下的颜色 上网搜寻后发现可以这么用，利用到了样式穿透的知识点 123/deep/ .el-input:focus &#123; border-color: #ffc7c7;&#125; 结果没有成功 后来问了我老哥，意识到了直接对el-input写样式是不行的，要找到确切的类名，像这样 123/deep/ .el-input__inner:focus &#123; border-color: #ffc7c7;&#125; 然后就ok了，ps:我用的是less，用deep是要有父元素的。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wendy-ljw.github.io/tags/vue/"},{"name":"element-ui","slug":"element-ui","permalink":"https://wendy-ljw.github.io/tags/element-ui/"}]},{"title":"vue项目解决跨域问题","slug":"vue-prob-1","date":"2023-01-03T08:10:24.000Z","updated":"2023-01-03T12:41:45.940Z","comments":true,"path":"2023/01/03/vue-prob-1/","link":"","permalink":"https://wendy-ljw.github.io/2023/01/03/vue-prob-1/","excerpt":"","text":"解决跨域问题 问题描述：前后端分离开发时，同时启动项目是两个不同的域名，因此需要跨域传输数据。 在vue.config.js中进行设置，如 12345678910111213141516module.exports = defineConfig(&#123; transpileDependencies: true, lintOnSave:false, // 关闭eslilnt校验 devServer:&#123; proxy: &#123; &#x27;/api&#x27;:&#123; target: &#x27;http://localhost:8081/change&#x27;, changeOrigin:true, pathRewrite:&#123; &#x27;^/api&#x27;:&#x27;&#x27; &#125; &#125; &#125; &#125;&#125;) 注意：修改完之后一定要重启项目！","categories":[{"name":"杂疑","slug":"杂疑","permalink":"https://wendy-ljw.github.io/categories/%E6%9D%82%E7%96%91/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wendy-ljw.github.io/tags/vue/"}]},{"title":"promise学习笔记","slug":"js-promise","date":"2022-11-25T07:35:21.000Z","updated":"2022-11-25T07:59:42.389Z","comments":true,"path":"2022/11/25/js-promise/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/25/js-promise/","excerpt":"","text":"一. Promise是什么？ Promise 是异步编程的一种解决方案，比传统的解决方案回调函数, 更合理和更强大。ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象 。 指定回调函数方式更灵活易懂。 解决异步 回调地狱 的问题。 1. 回调地狱 当一个回调函数嵌套一个回调函数的时候 就会出现一个嵌套结构 当嵌套的多了就会出现回调地狱的情况 比如我们发送三个 ajax 请求 第一个正常发送 第二个请求需要第一个请求的结果中的某一个值作为参数 第三个请求需要第二个请求的结果中的某一个值作为参数 1234567891011121314151617181920ajax(&#123; url: &#x27;我是第一个请求&#x27;, success (res) &#123; // 现在发送第二个请求 ajax(&#123; url: &#x27;我是第二个请求&#x27;， data: &#123; a: res.a, b: res.b &#125;, success (res2) &#123; // 进行第三个请求 ajax(&#123; url: &#x27;我是第三个请求&#x27;, data: &#123; a: res2.a, b: res2.b &#125;, success (res3) &#123; console.log(res3) &#125; &#125;) &#125; &#125;) &#125;&#125;) 回调地狱，其实就是回调函数嵌套过多导致的 当代码成为这个结构以后，已经没有维护的可能了 二. Promise使用 语法： 12345678new Promise(function (resolve, reject) &#123; // resolve 表示成功的回调 // reject 表示失败的回调&#125;).then(function (res) &#123; // 成功的函数&#125;).catch(function (err) &#123; // 失败的函数&#125;) 三. Promise 对象的状态Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。 123异步操作未完成（pending）异步操作成功（fulfilled）异步操作失败（rejected） 这三种的状态的变化途径只有两种。 12从“未完成”到“成功”从“未完成”到“失败” 一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。 因此，Promise 的最终结果只有两种。 12异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected。 四.Promise对象方法 Promise 是一个对象，也是一个构造函数。 1.Promise.resolve将现有对象转为 Promise 对象 123Promise.resolve(&#x27;kerwin&#x27;)// 等价于new Promise(resolve =&gt; resolve(&#x27;kerwin&#x27;)) 2.Promise.rejectPromise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 123const p = Promise.reject(&#x27;error&#x27;);// 等同于const p = new Promise((resolve, reject) =&gt; reject(&#x27;error&#x27;)) 3.Promise.allPromise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.all([p1, p2, p3]); p的状态由p1,p2,p3 决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 4.Promise.racePromise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 5.Promise.allSettledPromise.allSettled()方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。 123456789const promises = [ ajax(&#x27;/200接口&#x27;), ajax(&#x27;/401接口&#x27;) ];Promise.allSettled(promises).then(results=&gt;&#123; // 过滤出成功的请求 results.filter(item =&gt;item.status === &#x27;fulfilled&#x27;); 过滤出失败的请求 results.filter(item=&gt; item.status === &#x27;rejected&#x27;);&#125;) 6.Promise.any只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。 Promise.any()跟Promise.race()方法很像，只有一点不同，就是Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。 五.手写Promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/* * @作者: kerwin */function KerwinPromise(executor) &#123; this.status = &quot;pending&quot;; this.result = undefined; this.cb = [] var _this = this; function resolve(res) &#123; if (_this.status !== &quot;pending&quot;) return; // console.log(_this) _this.status = &quot;fulfilled&quot; _this.result = res; _this.cb.forEach(item =&gt; &#123; item.successCB &amp;&amp; item.successCB(_this.result) &#125;); &#125; function reject(res) &#123; if (_this.status !== &quot;pending&quot;) return; // console.log(&quot;reject&quot;) _this.status = &quot;rejected&quot; _this.result = res; _this.cb.forEach(item =&gt; &#123; item.failCB &amp;&amp; item.failCB(_this.result) &#125;); &#125; executor(resolve, reject)&#125;KerwinPromise.prototype.then = function (successCB, failCB) &#123; if(!successCB)&#123; successCB = value=&gt;value &#125; if(!failCB)&#123; failCB = error=&gt;error &#125; // successCB() return new KerwinPromise((resolve, reject) =&gt; &#123; if (this.status === &quot;fulfilled&quot;) &#123; var result = successCB &amp;&amp; successCB(this.result) // console.log(result); if (result instanceof KerwinPromise) &#123; result.then(res =&gt; &#123; // console.log(res) resolve(res); &#125;, err =&gt; &#123; // console.log(err) reject(err) &#125;) &#125; else &#123; resolve(result); &#125; &#125; if (this.status === &quot;rejected&quot;) &#123; var result = failCB &amp;&amp; failCB(this.result) if (result instanceof KerwinPromise) &#123; result.then(res =&gt; &#123; // console.log(res) resolve(res); &#125;, err =&gt; &#123; // console.log(err) reject(err) &#125;) &#125; else &#123; reject(result); &#125; &#125; if (this.status === &quot;pending&quot;) &#123; //收集回调 this.cb.push(&#123; successCB: () =&gt; &#123; var result = successCB &amp;&amp; successCB(this.result) if (result instanceof KerwinPromise) &#123; result.then(res =&gt; &#123; // console.log(res) resolve(res); &#125;, err =&gt; &#123; // console.log(err) reject(err) &#125;) &#125; else &#123; resolve(result); &#125; &#125;, failCB: () =&gt; &#123; var result = failCB &amp;&amp; failCB(this.result) if (result instanceof KerwinPromise) &#123; result.then(res =&gt; &#123; // console.log(res) resolve(res); &#125;, err =&gt; &#123; // console.log(err) reject(err) &#125;) &#125; else &#123; reject(result); &#125; &#125; &#125;) &#125; &#125;)&#125;KerwinPromise.prototype.catch= function(failCB)&#123; this.then(undefined,failCB)&#125; 六.Async与Await1.Asyncasync 函数，使得异步操作变得更加方便。 更好的语义。 返回值是 Promise。 1234async function test()&#123; &#125;test() 2.Awaitawait命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。 1234567891011async function test()&#123; var res1 = await ajax(&quot;http://localhost:3000/news1&quot;) var res2 = await ajax(&quot;http://localhost:3000/news2&quot;) return res2&#125;test().then(res=&gt;&#123; console.log(&quot;返回结果&quot;,res)&#125;).catch(err=&gt;&#123; console.log(&quot;err&quot;,err)&#125;) 3.错误处理123456try&#123; var res1 = await ajax(&quot;http://localhost:3000/news1&quot;) var res2 = await ajax(&quot;http://localhost:3000/news2&quot;)&#125;catch(err)&#123; console.log(&quot;err&quot;,err)&#125; 版权：千锋HTML5大前端教研院","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"https://wendy-ljw.github.io/tags/promise/"}]},{"title":"js高级-es6笔记(4)","slug":"js-es6-4","date":"2022-11-19T02:33:01.000Z","updated":"2023-01-08T03:09:56.565Z","comments":true,"path":"2022/11/19/js-es6-4/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/19/js-es6-4/","excerpt":"","text":"JavaScript 进阶 - 第4天一、深浅拷贝首先浅拷贝和深拷贝只针对像Object,Array这样的复杂对象，简单来说，浅拷贝只复制一层对象的属性，二深拷贝则复制了所有的层级。 1.1 浅拷贝 浅拷贝：拷贝的是地址 拷贝对象：Object.assgin() &#x2F; 展开运算符 {…obj} 拷贝数组：Array.prototype.concat() 或者 […arr] 123456789101112131415161718192021const obj = &#123; uname: &#x27;pink&#x27;, age: 18, family: &#123; baby: &#x27;小pink&#x27; &#125;&#125;// 浅拷贝1 const o = &#123; ...obj &#125;console.log(o)o.age = 20console.log(o)console.log(obj)// 2const o = &#123;&#125;Object.assign(o, obj)o.age = 20o.family.baby = &#x27;老pink&#x27;console.log(o)console.log(obj) 1.2 深拷贝 深拷贝：拷贝的是对象，不是地址 常见方法： 通过递归实现深拷贝 lodash&#x2F;cloneDeep 通过JSON.stringify()实现 1.2.1 通过递归实现深拷贝 递归函数：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数 简单理解：函数内部自己调用自己，这个函数就是递归函数 递归函数的作用和循环效果类似 由于递归很容易发生“栈溢出”错误，所以必须要加推出条件return 12345678910111213141516171819202122232425262728293031323334353637const obj = &#123; uname: &#x27;pink&#x27;, age: 18, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;], family: &#123; baby: &#x27;小pink&#x27; &#125;&#125;const o = &#123;&#125;// 拷贝函数function deepCopy(newObj, oldObj) &#123; debugger //打断点 for (let k in oldObj) &#123; // 处理数组的问题 一定先写数组 在写 对象 不能颠倒 if (oldObj[k] instanceof Array) &#123; newObj[k] = [] // newObj[k] 接收 [] hobby // oldObj[k] [&#x27;乒乓球&#x27;, &#x27;足球&#x27;] deepCopy(newObj[k], oldObj[k]) &#125; else if (oldObj[k] instanceof Object) &#123; newObj[k] = &#123;&#125; deepCopy(newObj[k], oldObj[k]) &#125; else &#123; // k 属性名 uname age oldObj[k] 属性值 18 // newObj[k] === o.uname 给新对象添加属性 newObj[k] = oldObj[k] &#125; &#125;&#125;deepCopy(o, obj) // 函数调用 两个参数 o 新对象 obj 旧对象console.log(o)o.age = 20o.hobby[0] = &#x27;篮球&#x27;o.family.baby = &#x27;老pink&#x27;console.log(obj)console.log([1, 23] instanceof Object)//true 1.2.2 js库loadash里面cloneDeep内部实现了深拷贝12345678910111213141516&lt;!-- 先引用 --&gt;&lt;script src=&quot;./lodash.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const obj = &#123; uname: &#x27;pink&#x27;, age: 18, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;], family: &#123; baby: &#x27;小pink&#x27; &#125; &#125; const o = _.cloneDeep(obj) console.log(o) o.family.baby = &#x27;老pink&#x27; console.log(obj)&lt;/script&gt; 1.2.3 利用JSON实现深拷贝1234567891011121314const obj = &#123; uname: &#x27;pink&#x27;, age: 18, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;], family: &#123; baby: &#x27;小pink&#x27; &#125;&#125;// 把对象转换为 JSON 字符串// console.log(JSON.stringify(obj))const o = JSON.parse(JSON.stringify(obj))console.log(o)o.family.baby = &#x27;123&#x27;console.log(obj) 对于字符串类型，浅拷贝是对值的复制，对于对象来说，浅拷贝是对对象地址的复制，并没有开辟新的栈，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会 改变，而深拷贝则是开辟新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。 二、异常处理 了解 JavaScript 中程序异常处理的方法，提升代码运行的健壮性。 2.1 throw异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行。 12345678910111213&lt;script&gt; function counter(x, y) &#123; if(!x || !y) &#123; // throw &#x27;参数不能为空!&#x27;; throw new Error(&#x27;参数不能为空!&#x27;) &#125; return x + y &#125; counter()&lt;/script&gt; 总结： throw 抛出异常信息，程序也会终止执行 throw 后面跟的是错误提示信息 Error 对象配合 throw 使用，能够设置更详细的错误信息 2.2 try … catch123456789101112131415161718192021&lt;script&gt; function foo() &#123; try &#123; // 查找 DOM 节点 const p = document.querySelector(&#x27;.p&#x27;) p.style.color = &#x27;red&#x27; &#125; catch (error) &#123; // try 代码段中执行有错误时，会执行 catch 代码段 // 查看错误信息 console.log(error.message) // 终止代码继续执行 return &#125; finally &#123; alert(&#x27;执行&#x27;) &#125; console.log(&#x27;如果出现错误，我的语句不会执行&#x27;) &#125; foo()&lt;/script&gt; 总结： try...catch 用于捕获错误信息 将预估可能发生错误的代码写在 try 代码段中 如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息 三、this 了解函数中 this 在不同场景下的默认值，知道动态指定函数 this 值的方法。 1.1 默认值this 是 JavaScript 最具“魅惑”的知识点，不同的应用场合 this 的取值可能会有意想不到的结果，在此我们对以往学习过的关于[this 默认的取值]情况进行归纳和总结。 普通函数普通函数的调用方式决定了 this 的值，即【谁调用 this 的值指向谁】，如下代码所示： 123456789101112131415161718192021222324252627282930313233343536&lt;button&gt;点击&lt;/button&gt;&lt;script&gt; // 普通函数： 谁调用我，this就指向谁 console.log(this) // window function fn() &#123; console.log(this) // window &#125; window.fn() window.setTimeout(function () &#123; console.log(this) // window &#125;, 1000) document.querySelector(&#x27;button&#x27;).addEventListener(&#x27;click&#x27;, function () &#123; console.log(this) // 指向 button &#125;) const obj = &#123; sayHi: function () &#123; console.log(this) // 指向 obj &#125; &#125; obj.sayHi() // 普通对象 const user = &#123; name: &#x27;小明&#x27;, walk: function () &#123; console.log(this) &#125; &#125; // 动态为 user 添加方法 user.sayHi = sayHi uesr.sayHello = sayHello // 函数调用方式，决定了 this 的值 user.sayHi() user.sayHello()&lt;/script&gt; 注： 普通函数没有明确调用者时 this 值为 window，严格模式下没有调用者时 this 的值为 undefined。 箭头函数箭头函数中的 this 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 this ！箭头函数中访问的 this 不过是箭头函数所在作用域的 this 变量。 箭头函数会默认帮我们绑定外层this的值，所以在箭头函数this的值和外层的this是一样的。 箭头函数中的this引用的就是最近作用域中的this 向外层作用域中，一层一层查找this，直到有this的定义 1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; console.log(this) // 此处为 window // 箭头函数 const sayHi = function() &#123; console.log(this) // 该箭头函数中的 this 为函数声明环境中 this 一致 &#125; // 普通对象 const user = &#123; name: &#x27;小明&#x27;, // 该箭头函数中的 this 为函数声明环境中 this 一致 walk: () =&gt; &#123; console.log(this) &#125;, sleep: function () &#123; let str = &#x27;hello&#x27; console.log(this) let fn = () =&gt; &#123; console.log(str) console.log(this) // 该箭头函数中的 this 与 sleep 中的 this 一致 &#125; // 调用箭头函数 fn(); &#125; &#125; // 动态添加方法 user.sayHi = sayHi // 函数调用 user.sayHi() user.sleep() user.walk()&lt;/script&gt; 在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此DOM事件回调函数不推荐使用箭头函数，如下代码所示： 123456789101112&lt;script&gt; // DOM 节点 const btn = document.querySelector(&#x27;.btn&#x27;) // 箭头函数 此时 this 指向了 window btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; console.log(this) &#125;) // 普通函数 此时 this 指向了 DOM 对象 btn.addEventListener(&#x27;click&#x27;, function () &#123; console.log(this) &#125;)&lt;/script&gt; 同样由于箭头函数 this 的原因，基于原型的面向对象也不推荐采用箭头函数，如下代码所示： 1234567891011&lt;script&gt; function Person() &#123; &#125; // 原型对像上添加了箭头函数 Person.prototype.walk = () =&gt; &#123; console.log(&#x27;人都要走路...&#x27;) console.log(this); // window &#125; const p1 = new Person() p1.walk()&lt;/script&gt; this指向以上归纳了普通函数和箭头函数中关于 this 默认值的情形，不仅如此 JavaScript 中还允许指定函数中 this 的指向，有 3 个方法可以动态指定普通函数中 this 的指向：call(),apply(),bind() call使用 call 方法调用函数，同时指定函数中 this 的值，使用方法如下代码所示： 123456789101112&lt;script&gt; const obj = &#123; uname: &#x27;pink&#x27; &#125; function fn(x, y) &#123; console.log(this) // window console.log(x + y) &#125; // 1. 调用函数 // 2. 改变 this 指向 fn.call(obj, 1, 2)&lt;/script&gt; 总结： call 方法能够在调用函数的同时指定 this 的值 使用 call 方法调用函数时，第1个参数为 this 指定的值 call 方法的其余参数会依次自动传入函数做为函数的参数 apply使用 call 方法调用函数，同时指定函数中 this 的值，使用方法如下代码所示： 123456789101112131415161718192021222324&lt;script&gt; const obj = &#123; age: 18 &#125; function fn(x, y) &#123; console.log(this) // &#123;age: 18&#125; console.log(x + y) &#125; // 1. 调用函数 // 2. 改变this指向 // fn.apply(this指向谁, 数组参数) fn.apply(obj, [1, 2]) // 3. 返回值 本身就是在调用函数，所以返回值就是函数的返回值 // 使用场景： 求数组最大值 // const max = Math.max(1, 2, 3) // console.log(max) const arr = [100, 44, 77] const max = Math.max.apply(Math, arr) const min = Math.min.apply(null, arr) console.log(max, min) // 使用场景： 求数组最大值 console.log(Math.max(...arr))&lt;/script&gt; 总结： apply 方法能够在调用函数的同时指定 this 的值 使用 apply 方法调用函数时，第1个参数为 this 指定的值 apply 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数 call与apply的区别在于参数不一样，apply传递的必须是数组 bindbind 方法并不会调用函数，而是创建一个指定了 this 值的新函数，使用方法如下代码所示： 1234567891011121314151617181920212223242526&lt;button&gt;发送短信&lt;/button&gt;&lt;script&gt;。、 const obj = &#123; age: 18 &#125; function fn() &#123; console.log(this) &#125; // 1. bind 不会调用函数 // 2. 能改变this指向 // 3. 返回值是个函数， 但是这个函数里面的this是更改过的obj const fun = fn.bind(obj) // console.log(fun) fun() // 需求，有一个按钮，点击里面就禁用，2秒钟之后开启 document.querySelector(&#x27;button&#x27;).addEventListener(&#x27;click&#x27;, function () &#123; // 禁用按钮 this.disabled = true window.setTimeout(function () &#123; // 在这个普通函数里面，我们要this由原来的window 改为 btn this.disabled = false &#125;.bind(this), 2000) // 这里的this 和 btn 一样 &#125;)&lt;/script&gt; 注：bind 方法创建新的函数，与原函数的唯一的变化是改变了 this 的值。 call apply bind总结 相同点： 都可以改变函数内部的this访问 区别点： call 和 apply 会调用函数，并且改变函数内部this指向 call 和 apply 传递的参数不一样，call传递参数aru1,aru2,…形式 apply必须使用数组形式 bind不会调用函数，可以改变函数内部this指向 主要应用场景： call调用函数并且可以传递函数 apply经常跟数组有关系，比如借助于数学对象实现数组最大值最小值 bind不调用函数，但是还可以改变this指向，比如改变定时器内部的this指向 四、防抖节流 防抖（debounce）所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间 节流（throttle）所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://wendy-ljw.github.io/tags/es6/"}]},{"title":"js高级-es6笔记(3)","slug":"js-es6-3","date":"2022-11-19T02:32:55.000Z","updated":"2023-01-08T03:09:52.615Z","comments":true,"path":"2022/11/19/js-es6-3/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/19/js-es6-3/","excerpt":"","text":"JavaScript 进阶 - 第3天 了解构造函数原型对象的语法特征，掌握 JavaScript 中面向对象编程的实现方式，基于面向对象编程思想实现 DOM 操作的封装。 了解面向对象编程的一般特征 掌握基于构造函数原型对象的逻辑封装 掌握基于原型对象实现的继承 理解什么原型链及其作用 能够处理程序异常提升程序执行的健壮性 一、面向对象 学习 JavaScript 中基于原型的面向对象编程序的语法实现，理解面向对象编程的特征。 面向对象编程是一种程序设计思想，它具有 3 个显著的特征：封装、继承、多态。 1.1 封装封装的本质是将具有关联的代码组合在一起，其优势是能够保证代码复用且易于维护，函数是最典型也是最基础的代码封装形式，面向对象思想中的封装仍以函数为基础，但提供了更高级的封装形式。 命名空间先来回顾一下以往代码封装的形式： 123456789101112131415&lt;script&gt; // 普通对象（命名空间）形式的封装 let beats = &#123; name: &#x27;狼&#x27;, setName: function (name) &#123; this.name = this.name; &#125;, getName() &#123; console.log(this.name); &#125; &#125; beats.setName(&#x27;熊&#x27;); beats.getName();&lt;/script&gt; 以往以普通对象（命名空间）形式封装的代码只是单纯把一系列的变量或函数组合到一起，所有的数据变量都被用来共享（使用 this 访问）。 构造函数对比以下通过面向对象的构造函数实现的封装： 12345678910111213141516171819202122&lt;script&gt; function Person() &#123; this.name = &#x27;佚名&#x27;; // 设置名字 this.setName = function (name) &#123; this.name = name; &#125; // 读取名字 this.getName = () =&gt; &#123; console.log(this.name); &#125; &#125; // 实例对像，获得了构造函数中封装的所有逻辑 let p1 = new Person(); p1.setName(&#x27;小明&#x27;); console.log(p1.name); // 实例对象 let p2 = new Person(); console.log(p2.name);&lt;/script&gt; 同样的将变量和函数组合到了一起并能通过 this 实现数据的共享，所不同的是借助构造函数创建出来的实例对象之间是彼此不影响的。 封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装前面我们学过的构造函数方法很好用，但是存在浪费内存的问题 总结： 构造函数体现了面向对象的封装特性 构造函数实例创建的对象彼此独立、互不影响 命名空间式的封装无法保证数据的独立性 注：可以举一些例子，如女娲造人等例子，加深对构造函数的理解。 原型对象实际上每一个构造函数都有一个名为 prototype 的属性，译成中文是原型的意思，prototype 的是对象类据类型，称为构造函数的原型对象，每个原型对象都具有 constructor 属性代表了该原型对象对应的构造函数。 12345678&lt;script&gt; function Person() &#123; &#125; // 每个函数都有 prototype 属性 console.log(Person.prototype);&lt;/script&gt; 了解了 JavaScript 中构造函数与原型对象的关系后，再来看原型对象具体的作用，如下代码所示： 1234567891011121314&lt;script&gt; function Person() &#123; // 此处未定义任何方法 &#125; // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () &#123; console.log(&#x27;Hi~&#x27;); &#125; // 实例化 let p1 = new Person(); p1.sayHi(); // 输出结果为 Hi~&lt;/script&gt; 构造函数 Person 中未定义任何方法，这时实例对象调用了原型对象中的方法 sayHi，接下来改动一下代码： 12345678910111213141516&lt;script&gt; function Person() &#123; // 此处定义同名方法 sayHi this.sayHi = function () &#123; console.log(&#x27;嗨!&#x27;); &#125; &#125; // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () &#123; console.log(&#x27;Hi~&#x27;); &#125; let p1 = new Person(); p1.sayHi(); // 输出结果为 嗨!&lt;/script&gt; 构造函数 Person 中定义与原型对象中相同名称的方法，这时实例对象调用则是构造函中的方法 sayHi。 通过以上两个简单示例不难发现 JavaScript 中对象的工作机制：当访问对象的属性或方法时，先在当前实例对象是查找，然后再去原型对象查找，并且原型对象被所有实例共享。 123456789101112131415161718192021&lt;script&gt; function Person() &#123; // 此处定义同名方法 sayHi this.sayHi = function () &#123; console.log(&#x27;嗨!&#x27; + this.name); &#125; &#125; // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () &#123; console.log(&#x27;Hi~&#x27; + this.name); &#125; // 在构造函数的原型对象上添加属性 Person.prototype.name = &#x27;小明&#x27;; let p1 = new Person(); p1.sayHi(); // 输出结果为 嗨! let p2 = new Person(); p2.sayHi();&lt;/script&gt; 总结：结合构造函数原型的特征，实际开发重往往会将封装的功能函数添加到原型对象中。 1.2 继承继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性。 龙生龙、凤生凤、老鼠的儿子会打洞描述的正是继承的含义，分别封装中国人和日本人的行为特征来理解编程中继承的含义，代码如下： 123456789101112131415161718192021222324252627282930313233&lt;script&gt; // 封装中国人的行为特征 function Chinese() &#123; // 中国人的特征 this.arms = 2; this.legs = 2; this.eyes = 2; this.skin = &#x27;yellow&#x27;; this.language = &#x27;中文&#x27;; // 中国人的行为 this.walk = function () &#123;&#125; this.sing = function () &#123;&#125; this.sleep = function () &#123;&#125; &#125; // 封装日本人的行为特征 function Japanese() &#123; // 日本人的特征 this.arms = 2; this.legs = 2; this.eyes = 2; this.skin = &#x27;yellow&#x27;; this.language = &#x27;日文&#x27;; // 日本人的行为 this.walk = function () &#123;&#125; this.sing = function () &#123;&#125; this.sleep = function () &#123;&#125; &#125;&lt;/script&gt; 其实我们都知道无论是中国人、日本人还是其它民族，人们的大部分特征是一致的，然而体现在代码中时人的相同的行为特征被重复编写了多次，代码显得十分冗余，我们可以将重复的代码抽离出来： 原型继承基于构造函数原型对象实现面向对象的继承特性。 12345678910111213141516171819202122232425&lt;script&gt; // 所有人 function Person() &#123; // 人的特征 this.arms = 2; this.legs = 2; this.eyes = 2; // 人的行为 this.walk = function () &#123;&#125; this.sing = function () &#123;&#125; this.sleep = function () &#123;&#125; &#125; // 中国人 function Chinese() &#123; this.skin = &#x27;yellow&#x27;; this.language = &#x27;中文&#x27;; &#125; // 日本人 function Japanese() &#123; this.skin = &#x27;yellow&#x27;; this.language = &#x27;日文&#x27;; &#125;&lt;/script&gt; 上述代码可以理解成将 Chinese 和 Japanese 共有的属性和方法提取出来了，也就是说 Chinese 和 Japanese 需要【共享】一些属性和方法，而原型对象的属性和方法恰好是可以被用来共享的，因此我们看如下代码： 12345678910111213141516171819202122232425262728&lt;script&gt; // 中国人 function Chinese() &#123; this.skin = &#x27;yellow&#x27;; this.language = &#x27;中文&#x27;; &#125; // 日本人 function Japanese() &#123; this.skin = &#x27;yellow&#x27;; this.language = &#x27;日文&#x27;; &#125; // 人们【共有】的行为特征 let people = &#123; // 人的特征 arms: 2, legs: 2, eyes:2, // 人的行为 walk: function () &#123;&#125;, sleep: function () &#123;&#125;, sing: function () &#123;&#125; &#125; // 为 prototype 重新赋值 Chinese.prototype = people; Chinese.prototype.constructor = Chinese;&lt;/script&gt; 如下图所示： 创建对象 people 将公共的的属性和方法独立出来，然后赋值给构造函数的 prototype 这样无论有多少个民族都可以共享公共的属性和方法了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script&gt; // 人们【共有】的行为特征 let people = &#123; // 人的特征 arms: 2, legs: 2, eyes:2, // 人的行为 walk: function () &#123;&#125;, sleep: function () &#123;&#125;, sing: function () &#123;&#125; &#125; // 中国人 function Chinese() &#123; this.skin = &#x27;yellow&#x27;; this.language = &#x27;中文&#x27;; &#125; // 日本人 function Japanese() &#123; this.skin = &#x27;yellow&#x27;; this.language = &#x27;日文&#x27;; &#125; function Englist() &#123; this.skin = &#x27;white&#x27;; this.language= &#x27;英文&#x27;; &#125; // 中国人 Chinese.prototype = people; Chinese.prototype.constructor = Chinese; let c1 = new Chinese(); // 日本人 Japanese.prototype = people; Janpanese.prototype.constructor = Japanese; // 英国人 English.prototype = people; English.prototype.constructor = English; // ...&lt;/script&gt; 继承是一种可以“不劳而获”的手段！！！上述代码中 Chinese、Japanese、English 都轻松的获得了 people 的公共的方法和属性，我们说 Chinese、Japanese、English 继承了 people。 上述代码中是以命名空间的形式实现的继承，事实上 JavaScript 中继承更常见的是借助构造函数来实现： 1234567891011121314151617181920212223242526272829303132333435363738&lt;script&gt; // 所有人 function Person() &#123; // 人的特征 this.arms = 2; this.legs = 2; this.eyes = 2; // 人的行为 this.walk = function () &#123;&#125; this.sing = function () &#123;&#125; this.sleep = function () &#123;&#125; &#125; // 封装中国人的行为特征 function Chinese() &#123; // 中国人的特征 this.skin = &#x27;yellow&#x27;; this.language = &#x27;中文&#x27;; &#125; // 封装日本人的行为特征 function Japanese() &#123; // 日本人的特征 this.skin = &#x27;yellow&#x27;; this.language = &#x27;日文&#x27;; &#125; // human 是构造函数 Person 的实例 let human = new Person(); // 中国人 Chinese.prototype = human; Chinese.prototype.constructor = Chinese; // 日本人 Japanese.prototype = human; Japanese.prototype.constructor = Japanese;&lt;/script&gt; 如下图所示： 原型链基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为原型链， 12345678910111213141516171819202122232425262728&lt;script&gt; // Person 构造函数 function Person() &#123; this.arms = 2; this.walk = function () &#123;&#125; &#125; // Person 原型对象 Person.prototype.legs = 2; Person.prototype.eyes = 2; Person.prototype.sing = function () &#123;&#125; Person.prototype.sleep = function () &#123;&#125; // Chinese 构造函数 function Chinese() &#123; this.skin = &#x27;yellow&#x27;; this.language = &#x27;中文&#x27;; &#125; // Chinese 原型对象 Chinese.prototype = new Person(); Chinese.prototype.constructor = Chinese; // 实例化 let c1 = new Chinese(); console.log(c1);&lt;/script&gt; 在 JavaScript 对象中包括了一个非标准备的属性 __proto__ 它指向了构造函数的原型对象，通过它可以清楚的查看原型对象的链状结构。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://wendy-ljw.github.io/tags/es6/"}]},{"title":"js高级-es6笔记(2)","slug":"js-es6-2","date":"2022-11-19T02:32:49.000Z","updated":"2023-01-08T03:09:46.562Z","comments":true,"path":"2022/11/19/js-es6-2/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/19/js-es6-2/","excerpt":"","text":"JavaScript 进阶 - 第2天 了解面向对象编程的基础概念及构造函数的作用，体会 JavaScript 一切皆对象的语言特征，掌握常见的对象属性和方法的使用。 了解面向对象编程中的一般概念 能够基于构造函数创建对象 理解 JavaScript 中一切皆对象的语言特征 理解引用对象类型值存储的的特征 掌握包装类型对象常见方法的使用 一、深入对象 了解面向对象的基础概念，能够利用构造函数创建对象。 创建对象三种方式 利用对象字面量创建对象 123const o = &#123; name: &#x27;Lili&#x27;&#125; 利用new Object创建对象 12const o = new Object(&#123; name: &#x27;Lili&#x27;&#125;)console.log(o) // &#123;name: &#x27;Lili&#x27;&#125; 利用构造函数创建对象 1.1 构造函数构造函数是专门用于创建对象的函数，如果一个函数使用 new 关键字调用，那么这个函数就是构造函数。 使用场景：常规的{···}语法允许创建一个对象，但继续创建相似对象还需重新写。此时可以通过构造函数来快速创建多个类似的对象。 12345678910function Pig(name , age , gender)&#123; this.name = name this.age = age this.gender = gender&#125;const Peppa = new Pig(&#x27;佩奇&#x27;,6,&#x27;女&#x27;)const Peppa1 = new Pig(&#x27;佩奇1&#x27;,7,&#x27;女&#x27;)const Peppa2 = new Pig(&#x27;佩奇2&#x27;,8,&#x27;男&#x27;)const Peppa3 = new Pig(&#x27;佩奇3&#x27;,9,&#x27;女&#x27;) 12345678&lt;script&gt; // 定义函数 function foo() &#123; console.log(&#x27;通过 new 也能调用函数...&#x27;); &#125; // 调用函数 new foo;&lt;/script&gt; 总结： new Object() new Date() 也是实例化构造函数 使用 new 关键字调用函数的行为被称为实例化 实例化构造函数时没有参数时可以省略 ()，但不提倡 构造函数的返回值即为新创建的对象，所以不要写return 构造函数内部的 return 返回的值无效！ 注：实践中为了从视觉上区分构造函数和普通函数，习惯将构造函数的首字母大写。 实例化执行过程 创建新对象 构造函数this指向新对象 执行构造函数代码，修改this，添加新的属性 返回新对象 1.2 实例成员通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。 123456789101112131415161718&lt;script&gt; // 构造函数 function Person() &#123; // 构造函数内部的 this 就是实例对象 // 实例对象中动态添加属性 this.name = &#x27;小明&#x27; // 实例对象动态添加方法 this.sayHi = function () &#123; console.log(&#x27;大家好~&#x27;) &#125; &#125; // 实例化，p1 是实例对象 // p1 实际就是 构造函数内部的 this const p1 = new Person() console.log(p1) console.log(p1.name) // 访问实例属性 p1.sayHi() // 调用实例方法&lt;/script&gt; 总结： 构造函数内部 this 实际上就是实例对象，为其动态添加的属性和方法即为实例成员 为构造函数传入参数，动态创建结构相同但值不同的对象 注：构造函数创建的实例对象彼此独立互不影响。 1.3 静态成员在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。 123456789101112131415&lt;script&gt; // 构造函数 function Person(name, age) &#123; // 省略实例成员 &#125; // 静态属性 Person.eyes = 2 Person.arms = 2 // 静态方法 Person.walk = function () &#123; console.log(&#x27;^_^人都会走路...&#x27;) // this 指向 Person console.log(this.eyes) &#125;&lt;/script&gt; 总结： 静态成员指的是添加到构造函数本身的属性和方法 一般公共特征的属性或方法静态成员设置为静态成员 静态成员方法中的 this 指向构造函数本身 二、内置构造函数 掌握各引用类型和包装类型对象属性和方法的使用。 在 JavaScript 中最主要的数据类型有 6 种，分别是字符串、数值、布尔、undefined、null 和 对象，常见的对象类型数据包括数组和普通对象。其中字符串、数值、布尔、undefined、null 也被称为简单类型或基础类型，对象也被称为引用类型。 在 JavaScript 内置了一些构造函数，绝大部的数据处理都是基于这些构造函数实现的，JavaScript 基础阶段学习的 Date 就是内置的构造函数。 1234567&lt;script&gt; // 实例化 let date = new Date(); // date 即为实例对象 console.log(date);&lt;/script&gt; 甚至字符串、数值、布尔、数组、普通对象也都有专门的构造函数，用于创建对应类型的数据。 2.1 引用类型ObjectObject 是内置的构造函数，用于创建普通对象。 三个常用的静态方法 静态方法就是只有构造函数和Object可以调用的方法 1234567891011121. Object.keys获得所有的属性名const o = &#123; uname: &#x27;pink&#x27;, age: 18 &#125;console.log(Object.keys(o)) //返回数组[&#x27;uname&#x27;, &#x27;age&#x27;]2. Object.values获得所有的属性值console.log(Object.values(o)) // [&#x27;pink&#x27;, 18]3. Object.assign对象的拷贝 // const oo = &#123;&#125; // Object.assign(oo, o) // console.log(oo)Object.assign(o, &#123; gender: &#x27;女&#x27; &#125;)console.log(o) 总结： 推荐使用字面量方式声明对象，而不是 Object 构造函数 Object.assign 静态方法创建新的对象 Object.keys 静态方法获取对象中所有属性 Object.values 表态方法获取对象中所有属性值 ArrayArray 是内置的构造函数，用于创建数组。 12345678&lt;script&gt; // 构造函数创建数组 let arr = new Array(5, 7, 8); // 字面量方式创建数组 let list = [&#x27;html&#x27;, &#x27;css&#x27;, &#x27;javascript&#x27;]&lt;/script&gt; 数组赋值后，无论修改哪个变量另一个对象的数据值也会相当发生改变。 reduce 累计器 返回函数是累计处理的结果，经常用于求和等语法：arr.reduce(function(累计值,当前元素 [,索引号][,源数组])&#123;&#125;,起始值)参数： 如果有起始值，则以起始值为准开始累计，累计值&#x3D;起始值 如果没有起始值，则累计值以数组的第一个数组元素作为起始值开始累计 后面每次遍历就会用后面的数组元素 累计到累计值里面(类似求和里面的sum) 1234567891011121314151617181920212223242526272829303132const arr = [ &#123; name: &#x27;小米&#x27;, price: 1999 &#125;, &#123; name: &#x27;华为&#x27;, price: 3999 &#125;, ]// 1. find 查找const mi = arr.find(item =&gt; item.name === &#x27;小米&#x27;)console.log(mi)// 2. every 每一个是否都符合条件，如果都符合返回 true ，否则返回falseconst arr1 = [10, 20, 30]const flag = arr1.every(item =&gt; item &gt;= 20)console.log(flag)const spec = &#123; size: &#x27;40cm*40cm&#x27;, color: &#x27;黑色&#x27; &#125;//1. 所有的属性值回去过来 数组console.log(Object.values(spec))// 2. 转换为字符串 数组join(&#x27;/&#x27;) 把数组根据分隔符转换为字符串console.log(Object.values(spec).join(&#x27;/&#x27;))document.querySelector(&#x27;div&#x27;).innerHTML = Object.values(spec).join(&#x27;/&#x27;)// Array.from(lis) 把伪数组转换为真数组const lis = document.querySelectorAll(&#x27;ul li&#x27;)// console.log(lis)// lis.pop() 报错const liss = Array.from(lis)liss.pop()console.log(liss) 总结： 推荐使用字面量方式声明数组，而不是 Array 构造函数 实例方法 forEach 用于遍历数组，替代 for 循环 (重点) 实例方法 filter 过滤数组单元值，生成新数组(重点) 实例方法 map 迭代原数组，生成新数组(重点) 实例方法 join 数组元素拼接为字符串，返回字符串(重点) 实例方法 find 查找元素， 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined(重点) 实例方法every 检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回 true，否则返回 false(重点) 实例方法some 检测数组中的元素是否满足指定条件 如果数组中有元素满足条件返回 true，否则返回 false 实例方法 concat 合并两个数组，返回生成新数组 实例方法 sort 对原数组单元值排序 实例方法 splice 删除或替换原数组单元 实例方法 reverse 反转数组 实例方法 findIndex 查找元素的索引值 ​ 2.2 包装类型在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，如下代码举例： 1234567891011&lt;script&gt; // 字符串类型 const str = &#x27;hello world!&#x27; // 统计字符的长度（字符数量） console.log(str.length) // 数值类型 const price = 12.345 // 保留两位小数 price.toFixed(2) // 12.34&lt;/script&gt; 之所以具有对象特征的原因是字符串、数值、布尔类型数据是 JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型。 StringString 是内置的构造函数，用于创建字符串。 1234567891011&lt;script&gt; // 使用构造函数创建字符串 let str = new String(&#x27;hello world!&#x27;); // 字面量创建字符串 let str2 = &#x27;你好，世界！&#x27;; // 检测是否属于同一个构造函数 console.log(str.constructor === str2.constructor); // true console.log(str instanceof String); // false&lt;/script&gt; 123456789101112131415161718//1. split 把字符串 转换为 数组 和 join() 相反const str = &#x27;pink,red&#x27;const arr = str.split(&#x27;,&#x27;)console.log(arr)const str1 = &#x27;2022-4-8&#x27;const arr1 = str1.split(&#x27;-&#x27;)console.log(arr1)//2. 字符串的截取 substring(开始的索引号[， 结束的索引号])//2.1 如果省略 结束的索引号，默认取到最后//2.2 结束的索引号不包含想要截取的部分const str = &#x27;今天又要做核酸了&#x27;console.log(str.substring(5, 7))//3. startsWith 判断是不是以某个字符开头const str = &#x27;pink老师上课中&#x27;console.log(str.startsWith(&#x27;pink&#x27;))//4. includes 判断某个字符是不是包含在一个字符串里面const str = &#x27;我是pink老师&#x27;console.log(str.includes(&#x27;pink&#x27;)) // true 总结： 实例属性 length 用来获取字符串的度长(重点) 实例方法 split(&#39;分隔符&#39;) 用来将字符串拆分成数组(重点) 实例方法 substring（需要截取的第一个字符的索引[,结束的索引号]） 用于字符串截取(重点) 实例方法 startsWith(检测字符串[, 检测位置索引号]) 检测是否以某字符开头(重点) 实例方法 includes(搜索的字符串[, 检测位置索引号]) 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点) 实例方法 toUpperCase 用于将字母转换成大写 实例方法 toLowerCase 用于将就转换成小写 实例方法 indexOf 检测是否包含某字符 实例方法 endsWith 检测是否以某字符结尾 实例方法 replace 用于替换字符串，支持正则匹配 实例方法 match 用于查找字符串，支持正则匹配 注：String 也可以当做普通函数使用，这时它的作用是强制转换成字符串数据类型。 NumberNumber 是内置的构造函数，用于创建数值。 123456789101112131415&lt;script&gt; // 使用构造函数创建数值 let x = new Number(&#x27;10&#x27;) let y = new Number(5) // 字面量创建数值 let z = 20// toFixed 方法可以让数字指定保留的小数位数const num = 10.923// console.log(num.toFixed())console.log(num.toFixed(1))const num1 = 10console.log(num1.toFixed(2))&lt;/script&gt; 总结： 推荐使用字面量方式声明数值，而不是 Number 构造函数 实例方法 toFixed 用于设置保留小数位的长度","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://wendy-ljw.github.io/tags/es6/"}]},{"title":"js高级-es6笔记","slug":"js-es6-1","date":"2022-11-17T02:35:20.000Z","updated":"2023-03-20T06:59:52.980Z","comments":true,"path":"2022/11/17/js-es6-1/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/17/js-es6-1/","excerpt":"","text":"JavaScript 进阶 - 第1天 学习作用域、变量提升、闭包等语言特征，加深对 JavaScript 的理解，掌握变量赋值、函数声明的简洁语法，降低代码的冗余度。 理解作用域对程序执行的影响 能够分析程序执行的作用域范围 理解闭包本质，利用闭包创建隔离作用域 了解什么变量提升及函数提升 掌握箭头函数、解析剩余参数等简洁语法 一、作用域 了解作用域对程序执行的影响及作用域链的查找机制，使用闭包函数创建隔离作用域避免全局变量污染。 作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问，作用域分为全局作用域和局部作用域。 1.1 局部作用域局部作用域分为函数作用域和块作用域。 函数作用域在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。 123456789101112&lt;script&gt; // 声明 counter 函数 function counter(x, y) &#123; // 函数内部声明的变量 const s = x + y console.log(s) // 18 &#125; // 设用 counter 函数 counter(10, 8) // 访问变量 s console.log(s)// 报错&lt;/script&gt; 总结： 函数内部声明的变量，在函数外部无法被访问 函数的参数也是函数内部的局部变量 不同函数内部声明的变量无法互相访问 函数执行完毕后，函数内部的变量实际被清空了 块作用域在 JavaScript 中使用 &#123;&#125; 包裹的代码称为代码块，代码块内部声明的变量外部将有可能无法被访问。 12345678910111213141516171819202122232425262728&lt;script&gt; &#123; // age 只能在该代码块中被访问 let age = 18; console.log(age); // 正常 &#125; // 超出了 age 的作用域 console.log(age) // 报错 let flag = true; if(flag) &#123; // str 只能在该代码块中被访问 let str = &#x27;hello world!&#x27; console.log(str); // 正常 &#125; // 超出了 str 的作用域 console.log(str); // 报错 for(let t = 1; t &lt;= 6; t++) &#123; // t 只能在该代码块中被访问 console.log(t); // 正常 &#125; // 超出了 t 的作用域 console.log(t); // 报错&lt;/script&gt; JavaScript 中除了变量外还有常量，常量与变量本质的区别是常量必须要有值且不允许被重新赋值，常量值为对象时其属性和方法允许重新赋值。 1234567891011121314151617181920&lt;script&gt; // 必须要有值 const version = &#x27;1.0.0&#x27;; // 不能重新赋值 // version = &#x27;1.0.1&#x27;; // 常量值为对象类型 const user = &#123; name: &#x27;小明&#x27;, age: 18 &#125; // 不能重新赋值 user = &#123;&#125;; // 属性和方法允许被修改 user.name = &#x27;小小明&#x27;; user.gender = &#x27;男&#x27;;&lt;/script&gt; 总结： let 声明的变量会产生块作用域，var 不会产生块作用域 const 声明的常量也会产生块作用域 不同代码块之间的变量无法互相访问 推荐使用 let 或 const 注：开发中 let 和 const 经常不加区分的使用，如果担心某个值会不小被修改时，则只能使用 const 声明成常量。 1.2 全局作用域&lt;script&gt; 标签和 .js 文件的最外层就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。 123456789&lt;script&gt; // 此处是全局 function sayHi() &#123; // 此处为局部 &#125; // 此处为全局&lt;/script&gt; 全局作用域中声明的变量，任何其它作用域都可以被访问，如下代码所示： 1234567891011121314151617181920&lt;script&gt; // 全局变量 name const name = &#x27;小明&#x27; // 函数作用域中访问全局 function sayHi() &#123; // 此处为局部 console.log(&#x27;你好&#x27; + name) &#125; // 全局变量 flag 和 x const flag = true let x = 10 // 块作用域中访问全局 if(flag) &#123; let y = 5 console.log(x + y) // x 是全局的 &#125;&lt;/script&gt; 总结： 为 window 对象动态添加的属性默认也是全局的，不推荐！ 函数中未使用任何关键字声明的变量为全局变量，不推荐！！！ 尽可能少的声明全局变量，防止全局变量被污染 JavaScript 中的作用域是程序被执行时的底层机制，了解这一机制有助于规范代码书写习惯，避免因作用域导致的语法错误。 1.3 作用域链在解释什么是作用域链前先来看一段代码： 12345678910111213&lt;script&gt; // 全局作用域 let a = 1 let b = 2 // 局部作用域 function f() &#123; let c // 局部作用域 function g() &#123; let d = &#x27;yo&#x27; &#125; &#125;&lt;/script&gt; 函数内部允许创建新的函数，f 函数内部创建的新函数 g，会产生新的函数作用域，由此可知作用域产生了嵌套的关系。 如下图所示，父子关系的作用域关联在一起形成了链状的结构，作用域链的名字也由此而来。 作用域链本质上是底层的变量查找机制，在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域，如下代码所示： 12345678910111213141516171819202122232425262728&lt;script&gt; // 全局作用域 let a = 1 let b = 2 // 局部作用域 function f() &#123; let c // let a = 10; console.log(a) // 1 或 10 console.log(d) // 报错 // 局部作用域 function g() &#123; let d = &#x27;yo&#x27; // let b = 20; console.log(b) // 2 或 20 &#125; // 调用 g 函数 g() &#125; console.log(c) // 报错 console.log(d) // 报错 f();&lt;/script&gt; 总结： 嵌套关系的作用域串联起来形成了作用域链 相同作用域链中按着从小到大的规则查找变量 子作用域能够访问父作用域，父级作用域无法访问子级作用域 1.4 垃圾回收机制1.4.1 什么是垃圾回收机制？垃圾回收机制（Garbage Collection) 简称 GCJS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收 1.4.2 内存泄漏正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法回收）的情况不再用到的内存，没有及时释放，就叫做内存泄漏 1.4.3 内存的生命周期JS环境中分配的内存，一般有如下生命周期： 内存分配： 当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 内存使用： 即读写内存，也就是使用变量、函数等 内存回收： 使用完毕，由垃圾回收自动回收不再使用的内容 说明： 全局变量一般不会回收（关闭页面回收）； 一般情况下局部变量的值，不用了会被自动回收掉 1.4.4 垃圾回收算法说明所谓垃圾回收，核心思想就是如何判断内存是否已经不再会被使用了，如果是，就视为垃圾，释放掉有两种常见的浏览器垃圾回收算法： 引用计数法和标记清除法 引用计数IE采用的引用计数算法，定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。算法： 跟踪记录每个值被引用的次数。 如果这个值的被引用了一次，那么就记录次数加1 多次引用会累加 如果减少一个引用就减1 如果引用次数是0，则释放内存12345678910&lt;script&gt; const person=&#123; //定义了person，引用次数为1 age:18, name:&#x27;ljw&#x27; &#125; const p=person //因为引用的是地址，所以引用次数加一 person=1 //person不再指向原来的结构体，所以引用次数减一 p=null //p也不再指向原来的结构体，所以引用次数减一 //此时引用次数为0，释放内存&lt;/script&gt; 由上面可以看出，引用计数算法是个简单有效的算法。但它却存在一个致命的问题：嵌套引用如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄漏。 12345678910&lt;script&gt; function fn()&#123; let o1 = &#123;&#125; let o2 = &#123;&#125; o1.a = o2 o2.a = o1 return &#x27;引用计数无法回收&#x27; &#125; fn()&lt;/script&gt; 因为他们的引用次数永远不会是0，这样的相互引用如果很大量的存在就会导致大量的内存泄漏 标记清除法 现在的浏览器已经不再使用引用计数算法了。现在浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。核心： 标记清除算法将“不再使用的对象”定义为“无法达到的对象” 就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收 1.5 闭包闭包（closure）是一种比较特殊和函数，使用闭包能够访问函数作用域中的变量。一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域 闭包&#x3D;内层函数+外层函数的变量 从代码形式上看闭包是一个做为返回值的函数，如下代码所示： 123456789101112131415161718&lt;script&gt; function foo() &#123; let i = 0; // 函数内部分函数 function bar() &#123; console.log(++i); &#125; // 将函数做为返回值 return bar; &#125; // fn 即为闭包函数 let fn = foo(); fn(); // 1&lt;/script&gt; 常见闭包的形式：外部可以访问使用函数内部的变量 总结： 闭包本质仍是函数，只不是从函数内部返回的 闭包能够创建外部可访问的隔离作用域，避免全局变量污染 过度使用闭包可能造成内存泄漏 注：回调函数也能访问函数内部的局部变量。 1.6 变量提升变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问。 把所有var声明的变量提升到当前作用域的最前面，只提升声明，不提升赋值 1234567&lt;script&gt; // 访问变量 str console.log(str + &#x27;world!&#x27;); // 声明变量 str var str = &#x27;hello &#x27;;&lt;/script&gt; 总结： 变量在未声明即被访问时会报语法错误 变量在声明之前即被访问，变量的值为 undefined let 声明的变量不存在变量提升，推荐使用 let 变量提升出现在相同作用域当中 实际开发中推荐先声明再访问变量 注：关于变量提升的原理分析会涉及较为复杂的词法分析等知识，而开发中使用 let 可以轻松规避变量的提升，因此在此不做过多的探讨，有兴趣可查阅资料。 二、函数 知道函数参数默认值、动态参数、剩余参数的使用细节，提升函数应用的灵活度，知道箭头函数的语法及与普通函数的差异。 2.1 函数提升函数提升与变量提升比较类似，是指函数在声明之前即可被调用。 会把所有函数声明提升到当前作用域的最前面只提升函数声明，不提升函数调用 1234567891011121314&lt;script&gt; // 调用函数 foo() // 声明函数 function foo() &#123; console.log(&#x27;声明之前即被调用...&#x27;) &#125; // 不存在提升现象 bar() // 错误 var bar = function () &#123; //因为变量被提升了，但是函数赋值没有被提升 console.log(&#x27;函数表达式不存在提升现象...&#x27;) &#125;&lt;/script&gt; 总结： 函数提升能够使函数的声明调用更灵活 函数表达式不存在提升的现象 函数提升出现在相同作用域当中 2.2 参数函数参数的使用细节，能够提升函数应用的灵活度。 默认值12345678910&lt;script&gt; // 设置参数默认值 function sayHi(name=&quot;小明&quot;, age=18) &#123; document.write(`&lt;p&gt;大家好，我叫$&#123;name&#125;，我今年$&#123;age&#125;岁了。&lt;/p&gt;`); &#125; // 调用函数 sayHi(); sayHi(&#x27;小红&#x27;); sayHi(&#x27;小刚&#x27;, 21);&lt;/script&gt; 总结： 声明函数时为形参赋值即为参数的默认值 如果参数未自定义默认值时，参数的默认值为 undefined 调用函数时没有传入对应实参时，参数的默认值被当做实参传入 动态参数arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参。 1234567891011121314&lt;script&gt; // 求生函数，计算所有参数的和 function sum() &#123; // console.log(arguments) let s = 0 for(let i = 0; i &lt; arguments.length; i++) &#123; s += arguments[i] &#125; console.log(s) &#125; // 调用求和函数 sum(5, 10)// 两个参数 sum(1, 2, 4) // 两个参数&lt;/script&gt; 总结： arguments 是一个伪数组 arguments 的作用是动态获取函数的实参 剩余参数12345678&lt;script&gt; function config(baseURL, ...other) &#123; console.log(baseURL) // 得到 &#x27;http://baidu.com&#x27; console.log(other) // other 得到 [&#x27;get&#x27;, &#x27;json&#x27;] &#125; // 调用函数 config(&#x27;http://baidu.com&#x27;, &#x27;get&#x27;, &#x27;json&#x27;);&lt;/script&gt; 总结： ... 是语法符号，置于最末函数形参之前，用于获取多余的实参 借助 ... 获取的剩余实参，是个真数组 展开运算符展开运算符（…），将一个数组进行展开 12const arr = [1,2,3,4,5]console.log(...arr) // 1 2 3 4 5 不会改变原数组 典型运用场景：求数组最大值（最小值）、合并数组等 123456//求最值console.log(Math.max(...arr))console.log(Math.min(...arr))//合并数组const arr2 = [3,4,5]const arr = [...arr1,...arr2] 展开运算符的剩余参数的区别：剩余参数：函数参数使用，得到真数组展开运算符：数组中使用，数组展开 2.3 箭头函数箭头函数是一种声明函数的简洁语法，它与普通函数并无本质的区别，差异性更多体现在语法格式上。 引入箭头函数的目的是更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁箭头函数更适用于那些本来需要匿名函数的地方 123456789101112131415161718192021222324&lt;script&gt; // 箭头函数 const foo = () =&gt; &#123; //本行相当于 const foo = function () &#123; console.log(&#x27;^_^ 长相奇怪的函数...&#x27;); &#125; // 调用函数 foo() //只有一个参数时可以省略圆括号 () const fn = a =&gt; &#123; console.log(a) &#125; //函数体只有一行代码时可以省略花括号 `&#123;&#125;`，并自动做为返回值被返回 const fn = a =&gt; a + a // 更简洁的语法 const form = document.querySelector(&#x27;form&#x27;) form.addEventListener(&#x27;click&#x27;, ev =&gt; ev.preventDefault()) //可以直接返回一个对象 const fn = (uname) =&gt; (&#123; uname: uname &#125;)&lt;/script&gt; 箭头函数中的this 123456789101112131415161718192021222324252627282930313233343536373839404142// 以前this的指向： 谁调用的这个函数，this 就指向谁 console.log(this) // window // 普通函数 function fn() &#123; console.log(this) // window &#125; window.fn() // 对象方法里面的this const obj = &#123; name: &#x27;andy&#x27;, sayHi: function () &#123; console.log(this) // obj &#125; &#125; obj.sayHi()// 2. 箭头函数的this 是上一层作用域的this 指向 const fn = () =&gt; &#123; console.log(this) // window &#125; fn()// 对象方法箭头函数 this const obj = &#123; uname: &#x27;pink老师&#x27;, sayHi: () =&gt; &#123; console.log(this) // this 指向谁？ window &#125; &#125; obj.sayHi()const obj = &#123; uname: &#x27;pink老师&#x27;, sayHi: function () &#123; console.log(this) // obj let i = 10 const count = () =&gt; &#123; console.log(this) // obj &#125; count() &#125;&#125;obj.sayHi() 总结： 箭头函数属于表达式函数，因此不存在函数提升 箭头函数只有一个参数时可以省略圆括号 () 箭头函数函数体只有一行代码时可以省略花括号 &#123;&#125;，并自动做为返回值被返回 箭头函数中没有 arguments，只能使用剩余函数 ... 动态获取实参 箭头函数不会创建自己的this,它只会从自己的作用域链的上一层延用this DOM事件回调函数不推荐使用箭头函数，特别是要用到this的时候 事件回调函数使用箭头函数时，this为全局的window 三、解构赋值 知道解构的语法及分类，使用解构简洁语法快速为变量赋值。 解构赋值是一种快速为变量赋值的简洁语法，本质上仍然是为变量赋值，分为数组解构、对象解构两大类型。 3.1 数组解构数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法，如下代码所示： 12345678910111213141516&lt;script&gt; // 普通的数组 let arr = [1, 2, 3]; // 批量声明变量 a b c // 同时将数组单元值 1 2 3 依次赋值给变量 a b c let [a, b, c] = arr; console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 let a = 1 let b = 2; //这里必须加分号 [b,a]=[a,b] //交换变量值&lt;/script&gt; 数组解构的细节 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 1. 变量多， 单元值少 ， undefined const [a, b, c, d] = [1, 2, 3] console.log(a) // 1 console.log(b) // 2 console.log(c) // 3 console.log(d) // undefined// 2. 变量少， 单元值多 const [a, b] = [1, 2, 3] console.log(a) // 1 console.log(b) // 2// 3. 剩余参数 变量少， 单元值多 const [a, b, ...c] = [1, 2, 3, 4] console.log(a) // 1 console.log(b) // 2 console.log(c) // [3, 4] 真数组// 4. 防止 undefined 传递 const [a = 0, b = 0] = [1, 2] const [a = 0, b = 0] = [] console.log(a) // 1 console.log(b) // 2// 5. 按需导入赋值 const [a, b, , d] = [1, 2, 3, 4] console.log(a) // 1 console.log(b) // 2 console.log(d) // 4 const arr = [1, 2, [3, 4]] console.log(arr[0]) // 1 console.log(arr[1]) // 2 console.log(arr[2]) // [3,4] console.log(arr[2][0]) // 3// 多维数组解构 const arr = [1, 2, [3, 4]] const [a, b, c] = [1, 2, [3, 4]] console.log(a) // 1 console.log(b) // 2 console.log(c) // [3,4]const [a, b, [c, d]] = [1, 2, [3, 4]]console.log(a) // 1console.log(b) // 2console.log(c) // 3console.log(d) // 4 总结： 赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量 变量的顺序对应数组单元值的位置依次进行赋值操作 变量的数量大于单元值数量时，多余的变量将被赋值为 undefined 变量的数量小于单元值数量时，可以通过 ... 获取剩余单元值，但只能置于最末位 允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效 注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析 3.2 对象解构对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法，如下代码所示： 1234567891011121314151617181920212223242526272829303132&lt;script&gt; // 普通对象 const user = &#123; name: &#x27;小明&#x27;, age: 18 &#125;; // 批量声明变量 name age // 同时将数组单元值 小明 18 依次赋值给变量 name age const &#123;name, age&#125; = user const &#123;name, age&#125; = &#123;name: &#x27;lili&#x27;,age: 18&#125; console.log(name) // 小明 console.log(age) // 18 //对象解构的变量名 可以重新改名 旧变量名: 新变量名 const &#123; uname: username, age &#125; = &#123; uname: &#x27;pink&#x27;, age: 18 &#125; console.log(username) console.log(age) // 解构数组对象 const pig = [ &#123; uname: &#x27;佩奇&#x27;, age: 6 &#125; ] const [&#123; uname, age &#125;] = pig console.log(uname) console.log(age) &lt;/script&gt; 多级对象解构 12345678910111213141516const person = [ &#123; name: &#x27;佩奇&#x27;, family: &#123; mother: &#x27;猪妈妈&#x27;, father: &#x27;猪爸爸&#x27;, sister: &#x27;乔治&#x27; &#125;, age: 6 &#125; ] const [&#123; name, family: &#123; mother, father, sister &#125; &#125;] = person console.log(name) console.log(mother) console.log(father) console.log(sister) 总结： 赋值运算符 = 左侧的 &#123;&#125; 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量 对象属性的值将被赋值给与属性名相同的变量 对象中找不到与变量名一致的属性时变量值为 undefined 允许初始化变量的默认值，属性不存在或单元值为 undefined 时默认值才会生效 注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析 两种必须加分号的情况 123456789101112131415// 1. 立即执行函数要加 (function () &#123; &#125;)(); (function () &#123; &#125;)();// 2. 使用数组的时候// const arr = [1, 2, 3]const str = &#x27;pink&#x27;;[1, 2, 3].map(function (item) &#123; console.log(item)&#125;)let a = 1let b = 2 ;[b, a] = [a, b]console.log(a, b) forEach遍历数组放法forEach()方法用于调用数组的每个元素，并将元素传递给回调函数 1234567891011被遍历的数组.forEach(function(当前数组元素，当前元素索引号)&#123; //函数体&#125;)// forEach 就是遍历 加强版的for循环 适合于遍历数组对象const arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;pink&#x27;]const result = arr.forEach(function (item, index) &#123; console.log(item) // 数组元素 red green pink console.log(index) // 索引号&#125;)// console.log(result) 注意：1.forEach主要是遍历数组2. 参数当前数组元素是必须要写的，索引号可选适合于遍历数组对象 filter筛选数组方法filter方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素主要使用场景：**筛选符合条件的元素，并返回筛选之后元素的新数组返回值： 返回数组，包含了符合条件的所有元素，如果没有符合条件的元素则返回空数组 1234567被遍历的数组.filter(function (currentValue,index)&#123; return 筛选条件&#125;)const newArr = arr.filter(item =&gt; item &gt;= 20) console.log(newArr)","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://wendy-ljw.github.io/tags/es6/"}]},{"title":"git学习笔记","slug":"git-note","date":"2022-11-15T09:27:28.000Z","updated":"2022-11-16T13:55:43.696Z","comments":true,"path":"2022/11/15/git-note/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/15/git-note/","excerpt":"","text":"Git实战听故事顺便学git，可能是全世界最好玩的git教程。 第一章 快速入门1.1 什么是GitGit是一个分布式的版本控制软件。 软件，类似于QQ、office、dota等安装到电脑上才能使用的工具。 版本控制，类似于毕业论文、写文案、视频剪辑等，需要反复修改和保留原历史数据。 分布式 文件夹拷贝 本地版本控制 集中式版本控制 分布式版本控制 1.2 为什么要做版本控制要保留之前所有的版本，以便回滚和修改。 1.3 安装git详见：https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git 1.4 git三大区域 工作区（红色区域） 已管理文件中的新增文件或修改文件（自动检测） 目的：方便写代码，方便修改，把改变的部分放这 暂存区（绿色区域） 把工作区里的文件用git add提交到暂存区 目的：起到一个缓冲的作用，是工作区与版本库的过度区域 版本库 把暂存区里的文件用git commit提交到版本库 目的：最终的每一个版本都放在这 第二章 “东北热”创业史2.1 第一阶段：单枪匹马开始干想要让git对一个目录进行版本控制需要以下步骤： 进入要管理的文件夹 执行初始化命令 1git init 管理目录下的文件状态 123git status注：新增的文件和修改过后的文件都是红色 管理指定文件（红变绿） 12git add 文件名git add . 个人信息配置：用户名、邮箱 【一次即可】 12git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 生成版本 1git commit -m &#x27;描述信息&#x27; //单引号中主要放对版本的描述信息，如初稿，版本号等 查看版本记录 1git log 2.2 第二阶段：拓展新功能12git add git commit -m &#x27;短视频&#x27; 新增了有短视频功能的版本 2.3 第三阶段：“约饭事件” 回滚至之前版本 12git log git reset --hard 版本号 版本号指的是git log执行后输出的commit后面的一大串字母数字 回滚至之后版本 12git reflog git reset --hard 版本号 这里的版本号是git reflog执行后输出的每一行最前面的一小串字母数字 2.4 小总结123456git init git add git commit git log git reflog git reset --hard 版本号 2.5 第四阶段：商城&amp;紧急修复bug2.5.1 分支分支可以给使用者提供多个环境的可以，意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 2.5.2 紧急修复bug方案 2.5.3 命令总结 查看分支 1git branch 创建分支 1git branch 分支名称 切换分支 1git checkout 分支名称 分支合并（可能产生冲突） 123git merge 要合并的分支注意：切换分支再合并 删除分支 1git branch -d 分支名称 2.5.4 工作流 2.6 第五阶段：进军三里屯有钱之后就要造呀，一个人在三里屯买了一层楼做办公室。 2.6.1 第一天上班前在家上传代码首先，需要注册github账号，并创建远程仓库，然后再执行如下命令，将代码上传到github。 12341. 给远程仓库起别名 git remote add origin 远程仓库地址2. 向远程推送代码 git push -u origin 分支 2.6.2 初次在公司新电脑下载代码12341. 克隆远程仓库代码 git clone 远程仓库地址 (内部已实现git remote add origin 远程仓库地址)2. 切换分支 git checkout 分支 在公司下载完代码后，继续开发 1234567891. 切换到dev分支进行开发 git checkout dev 2. 把master分支合并到dev [仅一次] git merge master3. 修改代码4. 提交代码 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.3 下班回到家继续写代码123456789101. 切换到dev分支进行开发 git checkout dev 2. 拉代码 git pull origin dev 3. 继续开发4. 提交代码 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.4 到公司继续开发12345678910111. 切换到dev分支进行开发 git checkout dev 2. 拉最新代码(不必再clone，只需要通过pull获取最新代码即可) git pull origin dev 3. 继续开发4. 提交代码 git add . git commit -m &#x27;xx&#x27; git push origin dev 开发完毕，要上线 123456781. 将dev分支合并到master，进行上线 git checkout master git merge dev git push origin master2. 把dev分支也推送到远程 git checkout dev git merge master git push origin dev 2.6.5 在公司约妹子忘记提交代码1234567891. 拉代码 git pull origin dev 2. 继续开发3. 提交代码 git add . git commit -m &#x27;xx&#x27;注：忘记push了 2.6.6 回家继续写代码1234567891. 拉代码，发现在公司写的代码忘记提交... git pull origin dev 2. 继续开发其他功能 3. 把dev分支也推送到远程 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.7 到公司继续写代码12345678910111. 拉代码，把晚上在家写的代码拉到本地(有合并、可能产生冲突) git pull origin dev 2. 如果有冲突，手动解决冲突 3. 继续开发其他功能 4. 把dev分支也推送到远程 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.8 其他1234git pull origin dev等价于git fetch origin devgit merge origin/dev 2.6.9 rebase的作用？rebase可以保持提交记录简洁，不分叉。 2.6.9 快速解决冲突 安装beyond compare 在git中配置 123git config --local merge.tool bc3git config --local mergetool.path &#x27;/usr/local/bin/bcomp&#x27;git config --local mergetool.keepBackup false 应用beyond compare 解决冲突 1git mergetool 2.7 小总结 添加远程连接（别名） 1git remote add origin 地址 推送代码 1git push origin dev 下载代码 1git clone 地址 拉取代码 1234git pull origin dev 等价于git fetch origin devgit merge origin/dev 保持代码提交整洁（变基） 1git rebase 分支 记录图形展示 1git log --graph --pretty=format:&quot;%h %s&quot; 2.8 第六阶段：多人协同开发工作流 2.8.1 创建项目&amp;邀请成员协同开发时，需要所有成员都可以对同一个项目进行操作，需要邀请成员并赋予权限，否则无法开发。github支持两种创建项目的方式（供多人协同开发）。 合作者，将用户添加到仓库合作者中之后，该用户就可以向当前仓库提交代码。 组织，将成员邀请进入组织，组织下可以创建多个仓库，组织成员可以向组织下仓库提交代码。 扩展：Tag标签管理为了能清晰的管理版本，在公司不会直接使用commit来做版本，会基于Tag来实现：v1.0 、 v1.2 、v2.0 版本。 1234567git tag -a v1.0 -m &#x27;版本介绍&#x27; 创建本地创建Tag信息git tag -d v1.0 删除Taggit push origin --tags 将本地tag信息推送到远程仓库git pull origin --tags 更新本地tag版本信息git checkout v.10 切换taggit clone -b v0.1 地址 指定tag下载代码 2.8.2 小弟开发 小弟注册Github 或 Gitlab账号 邀请小弟进入组织（默认对组织中的项目具有读权限） 邀请小弟成为某项目的合作者 小弟在自己电脑上下载代码并开发 123456789git clone https://github.com/oldboy-org/dbhot.gitcd dbhotgit checkout devgit checkout -b dzz 写代码...git add .git commit -m &#x27;斗地主功能开发完成&#x27;git push origin ddz 2.8.3 code review 配置，代码review之后才能合并到dev分支。 小弟提交 code review申请 组长做 code review 2.8.4 提测上线（预发布）由专门团队或团队leader执行以下步骤： 基于dev分值创建release分值 12git checkout devgit checkout -b release 测试等 合并到master 123使用pull request或本地将release合并到master分支 在master分支打tag 12git tag -a v2 -m &#x27;第二版 斗地主功能&#x27;git push origin --tags 运维人员就可以去下载代码做上线了 1git clone -b v2 地址 2.9 第七阶段：给开源软件贡献代码 fork源代码将别人源代码拷贝到我自己的远程仓库。 在自己仓库进行修改代码 给源代码的作者提交 修复bug的申请（pull request） 第三章 其他3.1 配置 项目配置文件：项目&#x2F;.git&#x2F;config 12git config --local user.name &#x27;武沛齐&#x27;git config --local user.email &#x27;wupeiqi@xx.com&#x27; 全局配置文件: ~&#x2F;.gitconfig 12git config --global user.name &#x27;wupeiq&#x27;git config --global user.name &#x27;wupeiqi@xx.com&#x27; 系统配置文件：&#x2F;etc&#x2F;.gitconfig 1234git config --system user.name &#x27;wupeiq&#x27;git config --system user.name &#x27;wupeiqi@xx.com&#x27;注意：需要有root权限 应用场景： 12345678git config --local user.name &#x27;武沛齐&#x27;git config --local user.email &#x27;wupeiqi@xx.com&#x27;git config --local merge.tool bc3git config --local mergetool.path &#x27;/usr/local/bin/bcomp&#x27;git config --local mergetool.keepBackup falsegit remote add origin 地址 ，默认添加在本地配置文件中(--local) 3.2 免密码登录 URL中体现 12345原来的地址：https://github.com/WuPeiqi/dbhot.git修改的地址：https://用户名:密码@github.com/WuPeiqi/dbhot.gitgit remote add origin https://用户名:密码@github.com/WuPeiqi/dbhot.gitgit push origin master SSH实现 123456781. 生成公钥和私钥(默认放在 ~/.ssh目录下，id_rsa.pub公钥、id_rsa私钥） ssh-keygen2. 拷贝公钥的内容，并设置到github中。3. 在git本地中配置ssh地址 git remote add origin git@github.com:WuPeiqi/dbhot.git 4. 以后使用 git push origin master git自动管理凭证 3.3 git忽略文件让Git不再管理当前目录下的某些文件。 1234*.h!a.hfiles/*.py[c|a|d] 更多参考：https://github.com/github/gitignore 3.4 github任务管理相关 issues，文档以及任务管理。 wiki，项目文档。 结课感谢各位同学的关注和学习，希望git实战课程对你能够有所帮助，更多资源关注： 小猿圈 &lt;www.apeland.cn&gt; 路飞学城 &lt;www.luffycity.com&gt; 老男孩IT教育 &lt;www.oldboyedu.com&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","permalink":"https://wendy-ljw.github.io/tags/git/"}]},{"title":"原型与原型链","slug":"js-prototype","date":"2022-11-14T09:44:36.000Z","updated":"2023-01-08T03:10:03.586Z","comments":true,"path":"2022/11/14/js-prototype/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/14/js-prototype/","excerpt":"","text":"原型与原型链原型：被用于复制现有实例来生成新实例的函数 原型链：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。 构造函数：用new来调用，就是为了创建一个自定义类，构造函数和普通函数本质上没什么区别，只不过使用了new关键字创建对象的函数，被叫做了构造函数。 实例：是类在实例化之后一个一个具体的对象 原型JS中每一个函数都有一个prototype属性，这个属性指向函数的原型对象，每一个由原型对象派生的子对象，都有相同的属性。子对象就叫构造函数，从实例原型中获取相同的属性。 我们所创建的每一格函数，解析器都会向函数中添加一个属性prototype这个属性对应着一个对象，这个对象就是我们所谓的原型对象 打比方说： 12345678function Person(age) &#123; this.age = age &#125;Person.prototype.name = &#x27;ljw&#x27;var person1 = new Person()var person2 = new Person()console.log(person1.name) //ljwconsole.log(person2.name) //ljw 其中，函数的prototype指向了一个对象，而这个对象正是调用构造函数时创建的实例的原型，也就是person1和person2的原型。 _Proto __Proto _是每一个子对象（除null外）都会有的一个属性，指向该对象的原型 当函数以构造函数的形式调用时，它所创造的对象中都会有一个隐含的属性指向该构造函数的原型对象，我们可以通过_proto_来访问属性 12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 此属性可以访问原型，但并不存在于Person.prototype中，来自于Object.prototype,类似getter&#x2F;setter，即使用obj._proto_时，可以理解为返回Object.getPrototypeOf(obj) 构造函数constructor每个原型都有一个constructor属性，指向该关联的构造函数 如果函数作为普通函数调用prototype没有任何作用 1234function Person() &#123;&#125;console.log(Person===Person.prototype.constructor) //true 12345678910function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层(也就是Object)为止。 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中 12345678910111213function Person() &#123;&#125;Person.prototype.name = &#x27;Kevin&#x27;;var person = new Person();person.name = &#x27;Daisy&#x27;;console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.proto ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 原型链原型对象也是对象，所以它也有原型，当我们使用一个对象的属性或方法时，会按照以下步骤： 先在自身中寻找 自身中如果有，则直接使用 如果自身中没有则去原型对象中寻找，如果原型对象中有，则使用 如果原型对象中没有，则去原型对象的原型对象中寻找，直到找到Object对象的原型 Object有原型，但Object的原型没有原型，如果在Object的原型里没有找到，则返回undefined 整个查找过程都是顺着__proto__属性，一步一步往上查找，形成了像链条一样的结构，这个结构，就是原型链。所以，原型链也叫作隐式原型链。 检查属性函数 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true1console.log(&quot;name&quot; in person) //true 使用对象的hasOwnProperty()来检查对象自身中是否含有该属性，只有当对象自身中含有属性时，才会返回true1console.log(&quot;person.hasOwnProperty()&quot;) //false","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"}]},{"title":"Markdown使用指南","slug":"markdown","date":"2022-11-11T01:12:03.000Z","updated":"2023-01-08T03:09:20.318Z","comments":true,"path":"2022/11/11/markdown/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/11/markdown/","excerpt":"我的第一篇博客，从刚学来的markdown开始","text":"我的第一篇博客，从刚学来的markdown开始 标题1.分级标题&#x3D;&#x3D;&#x3D;&#x3D;上面一行的内容就是一级标题—-上面一行的内容就是二级标题&#x3D;&#x3D;&#x3D;&#x3D;或—-都要单独一行 1234这是一个一级标题============================这是一个二级标题---------------------------- 第二种写法用#放标题最前面，几个#表示是几级标题 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 2.斜体和粗体代码 1234*斜体*或_斜体_**粗体*****加粗斜体***~~删除线~~ 显示效果 这是一段斜体 这是一段粗体 这是一段加粗斜体 这是一段删除线 3.超链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 3.1 行内式 [链接名](链接地址 “链接的title属性”)链接的title属性可以不加 12欢迎来到[重庆理工大学](https://www.cqut.edu.cn/)欢迎来到[重庆理工大学](https://www.cqut.edu.cn/ &quot;重庆理工大学&quot;) 显示效果 欢迎来到重庆理工大学 欢迎来到重庆理工大学 3.2 参考式 利用变量的形式&#x2F;[链接名][链接变量名] 一般用在学术论文上 当某个链接在文章中多处使用的时候，也可以使用参考式超链接，会很方便 1234比如说[CQUT][1]、[Google][g][1]:https://www.cqut.edu.cn &quot;CQUT&quot;[g]:http://www.google.com &quot;Google&quot; 显示效果 比如说CQUT、Google 3.3 自动连接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。 1&lt;https://www.cqut.edu.cn/&gt; 显示效果 https://www.cqut.edu.cn/ 4.列表4.1 无序列表使用 *，+，- 表示无序列表。 123- 哈哈- 嘿嘿- 嘻嘻 显示效果 哈哈 嘿嘿 嘻嘻 4.2 有序列表有序列表则使用数字接着一个英文句点。 1231. 嘿嘿2. 哈哈3. 嘻嘻 显示效果 嘿嘿 哈哈 嘻嘻 4.3 列表缩进1234567- 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！- 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 4.4 包含段落的列表12345678* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ * 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 4.5 列表嵌套1234567* 无序1 1. 有序1 2. 有序2 - 无序3 3. 有序3* 无序2 - 无序4 显示效果 无序1 有序1 有序2 无序3 有序3 无序2 无序4 5.区块引用1&gt;这是一个区块引用 显示效果 这是一个区块引用 还可嵌套引用 5.1 嵌套列表12345&gt;- 嵌套无序列表&gt;- haha&gt;1. 嵌套有序列表&gt;2.xixi 显示效果 嵌套无序列表 haha 嵌套有序列表 xixi 5.2 嵌套代码123&gt;代码&gt;&gt; return 0; 显示效果 代码 return 0; 6.图像与超链接用法相似 6.1 行内式1![花花](http://xtzl.wentexl.cn/ljw/bjt/b0002.jpg) 显示效果 6.2 参考式12![花花][f][f]:http://xtzl.wentexl.cn/ljw/bjt/b0002.jpg &quot;花花&quot; 显示效果 7.注脚在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 1234567使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。[^1]:Markdown是一种纯文本标记语言[^2]:HyperTextMarkupLanguage超文本标记语言[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文 显示效果 使用 Markdown^1可以效率的书写文档, 直接转换成 HTML^2, 你可以使用 Leanote^Le 编辑器进行书写。 8.引用公式$表示行内公式 $$表示整行公式 一元二次方程$y=ax^2+bx+c$ 显示效果 一元二次方程$y&#x3D;ax^2+bx+c$ 12$$y=ax^2+bx+c$$$$x=x+1$$ 显示效果$$y&#x3D;ax^2+bx+c$$$$x&#x3D;x+1$$ 9.表格 不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。123456789101112131415161718普通格式|表头|表头||-|-||1|单元格||2|表格|简单格式|表头|表头|-|-|1|单元格||2|表格|对齐|左对齐|右对齐|居中对齐|:-|-:|:-:|1|单元格|表格||2|表格|单元格| 显示效果 普通格式 表头 表头 1 单元格 2 表格 简单格式 表头 表头 1 单元格 2 表格 对齐 左对齐 右对齐 居中对齐 1 单元格 表格 2 表格 单元格 10.分隔线用三个及以上的*-_以及空格组成，显示效果都一样 12345**** * ******- - ----------- 显示效果 11.代码对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”&#96;”符号（一般在ESC键下方）包裹代码。 11.1 行内式记得`return 0` 显示效果 记得return 0 11.2 多行代码利用缩进或者是用&#96;&#96;&#96;&#96;&#96;&#96;包裹代码 12345#include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;Hello world\\n&quot;);&#125; 显示效果 #include &lt;stdio.h&gt; int main(void) &#123; printf(&quot;Hello world\\n&quot;); &#125; 11.3 直接引用HTML1&lt;div&gt;这是一个块&lt;/div&gt; 显示效果 这是一个块 11.4 转义引用可以用反斜杠打印特殊符号，如： 123456789101112\\ 反斜线` 反引号* 星号_ 下划线&#123;&#125; 花括号[] 方括号() 小括号# 井字号+ 加号- 减号. 英文句点! 感叹号","categories":[{"name":"总结","slug":"总结","permalink":"https://wendy-ljw.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://wendy-ljw.github.io/tags/markdown/"}]},{"title":"文章演示页面","slug":"post-example","date":"2021-07-24T16:00:00.000Z","updated":"2023-01-08T03:10:10.335Z","comments":true,"path":"2021/07/25/post-example/","link":"","permalink":"https://wendy-ljw.github.io/2021/07/25/post-example/","excerpt":"显示在首页的内容","text":"显示在首页的内容 一级标题二级标题三级标题四级标题瀑布流图片 相片集 字符效果和横线等 删除线斜体字 斜体字粗体 粗体粗斜体 粗斜体 上标：X2，下标：O2 缩写(同HTML的abbr标签) 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启 The HTML specification is maintained by the W3C. 引用 Blockquotes 引用文本 Blockquotes 锚点与链接 Links普通链接 普通链接带描述 直接链接：https://github.com 多语言代码高亮 Codes行内代码 Inline code执行命令：npm install marked JS代码123456789101112131415161718192021222324252627282930313233343536function test()&#123; console.log(&quot;Hello world!&quot;);&#125; (function()&#123; var box = function()&#123; return box.fn.init(); &#125;; box.prototype = box.fn = &#123; init : function()&#123; console.log(&#x27;box.init()&#x27;); return this; &#125;, add : function(str)&#123; alert(&quot;add&quot;, str); return this; &#125;, remove : function(str)&#123; alert(&quot;remove&quot;, str); return this; &#125; &#125;; box.fn.init.prototype = box.fn; window.box =box;&#125;)();var testBox = box();testBox.add(&quot;jQuery&quot;).remove(&quot;jQuery&quot;); HTML代码 HTML codes12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest=&quot;utf-8&quot; /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello world!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 图片 Images 图片加链接 (Image + Link)： 列表 Lists无序列表 列表一 列表二 列表二-1 列表二-2 列表二-3 列表三 列表一 列表二 列表三 有序列表 第一行 第二行 第三行 GFM task list GFM task list 1 GFM task list 2 GFM task list 3 GFM task list 3-1 GFM task list 3-2 GFM task list 3-3 GFM task list 4 GFM task list 4-1 GFM task list 4-2 绘制表格 Tables 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234","categories":[{"name":"种类","slug":"种类","permalink":"https://wendy-ljw.github.io/categories/%E7%A7%8D%E7%B1%BB/"}],"tags":[{"name":"标签","slug":"标签","permalink":"https://wendy-ljw.github.io/tags/%E6%A0%87%E7%AD%BE/"}]}],"categories":[{"name":"总结","slug":"总结","permalink":"https://wendy-ljw.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"面试","slug":"面试","permalink":"https://wendy-ljw.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"杂疑","slug":"杂疑","permalink":"https://wendy-ljw.github.io/categories/%E6%9D%82%E7%96%91/"},{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"种类","slug":"种类","permalink":"https://wendy-ljw.github.io/categories/%E7%A7%8D%E7%B1%BB/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://wendy-ljw.github.io/tags/es6/"},{"name":"css","slug":"css","permalink":"https://wendy-ljw.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://wendy-ljw.github.io/tags/html/"},{"name":"http","slug":"http","permalink":"https://wendy-ljw.github.io/tags/http/"},{"name":"vue","slug":"vue","permalink":"https://wendy-ljw.github.io/tags/vue/"},{"name":"git","slug":"git","permalink":"https://wendy-ljw.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://wendy-ljw.github.io/tags/hexo/"},{"name":"element-ui","slug":"element-ui","permalink":"https://wendy-ljw.github.io/tags/element-ui/"},{"name":"promise","slug":"promise","permalink":"https://wendy-ljw.github.io/tags/promise/"},{"name":"markdown","slug":"markdown","permalink":"https://wendy-ljw.github.io/tags/markdown/"},{"name":"标签","slug":"标签","permalink":"https://wendy-ljw.github.io/tags/%E6%A0%87%E7%AD%BE/"}]}