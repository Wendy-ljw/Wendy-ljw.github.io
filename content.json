{"meta":{"title":"Wendy","subtitle":"","description":"","author":"Wendy","url":"https://wendy-ljw.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2022-11-10T11:15:45.811Z","updated":"2022-11-10T11:15:45.811Z","comments":true,"path":"archive.html","permalink":"https://wendy-ljw.github.io/archive.html","excerpt":"","text":""},{"title":"关于","date":"2022-11-15T12:46:33.299Z","updated":"2022-11-15T12:46:33.299Z","comments":true,"path":"about.html","permalink":"https://wendy-ljw.github.io/about.html","excerpt":"","text":"今天我终于把我的博客搭建成功了"},{"title":"朋友","date":"2022-11-15T12:46:38.231Z","updated":"2022-11-15T12:46:38.231Z","comments":true,"path":"PY.html","permalink":"https://wendy-ljw.github.io/PY.html","excerpt":"","text":"戳这可见文特的博客"},{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2022-11-10T11:04:24.717Z","comments":true,"path":"page/index.html","permalink":"https://wendy-ljw.github.io/page/index.html","excerpt":"","text":"This is a page test."}],"posts":[{"title":"git学习笔记","slug":"git-note","date":"2022-11-15T09:27:28.000Z","updated":"2022-11-15T10:17:02.131Z","comments":true,"path":"2022/11/15/git-note/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/15/git-note/","excerpt":"","text":"Git实战听故事顺便学git，可能是全世界最好玩的git教程。 第一章 快速入门1.1 什么是GitGit是一个分布式的版本控制软件。 软件，类似于QQ、office、dota等安装到电脑上才能使用的工具。 版本控制，类似于毕业论文、写文案、视频剪辑等，需要反复修改和保留原历史数据。 分布式 文件夹拷贝 本地版本控制 集中式版本控制 分布式版本控制 1.2 为什么要做版本控制要保留之前所有的版本，以便回滚和修改。 1.3 安装git详见：https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git 1.4 git三大区域 工作区（红色区域） 已管理文件中的新增文件或修改文件（自动检测） 目的：方便写代码，方便修改，把改变的部分放这 暂存区（绿色区域） 把工作区里的文件用git add提交到暂存区 目的：起到一个缓冲的作用，是工作区与版本库的过度区域 版本库 把暂存区里的文件用git commit提交到版本库 目的：最终的每一个版本都放在这 第二章 “东北热”创业史2.1 第一阶段：单枪匹马开始干想要让git对一个目录进行版本控制需要以下步骤： 进入要管理的文件夹 执行初始化命令 git init 管理目录下的文件状态 git status注：新增的文件和修改过后的文件都是红色 管理指定文件（红变绿） git add 文件名git add . 个人信息配置：用户名、邮箱 【一次即可】 git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 生成版本 git commit -m &#x27;描述信息&#x27; //单引号中主要放对版本的描述信息，如初稿，版本号等 查看版本记录 git log 2.2 第二阶段：拓展新功能git add git commit -m &#x27;短视频&#x27; 新增了有短视频功能的版本 2.3 第三阶段：“约饭事件” 回滚至之前版本 git log git reset --hard 版本号 版本号指的是git log执行后输出的commit后面的一大串字母数字 回滚至之后版本 git reflog git reset --hard 版本号 这里的版本号是git reflog执行后输出的每一行最前面的一小串字母数字 2.4 小总结git init git add git commit git log git reflog git reset --hard 版本号 2.5 第四阶段：商城&amp;紧急修复bug2.5.1 分支分支可以给使用者提供多个环境的可以，意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 2.5.2 紧急修复bug方案 2.5.3 命令总结 查看分支 git branch 创建分支 git branch 分支名称 切换分支 git checkout 分支名称 分支合并（可能产生冲突） git merge 要合并的分支注意：切换分支再合并 删除分支 git branch -d 分支名称 2.5.4 工作流 2.6 第五阶段：进军三里屯有钱之后就要造呀，一个人在三里屯买了一层楼做办公室。 2.6.1 第一天上班前在家上传代码首先，需要注册github账号，并创建远程仓库，然后再执行如下命令，将代码上传到github。 1. 给远程仓库起别名 git remote add origin 远程仓库地址2. 向远程推送代码 git push -u origin 分支 2.6.2 初次在公司新电脑下载代码1. 克隆远程仓库代码 git clone 远程仓库地址 (内部已实现git remote add origin 远程仓库地址)2. 切换分支 git checkout 分支 在公司下载完代码后，继续开发 1. 切换到dev分支进行开发 git checkout dev 2. 把master分支合并到dev [仅一次] git merge master3. 修改代码4. 提交代码 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.3 下班回到家继续写代码1. 切换到dev分支进行开发 git checkout dev 2. 拉代码 git pull origin dev 3. 继续开发4. 提交代码 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.4 到公司继续开发1. 切换到dev分支进行开发 git checkout dev 2. 拉最新代码(不必再clone，只需要通过pull获取最新代码即可) git pull origin dev 3. 继续开发4. 提交代码 git add . git commit -m &#x27;xx&#x27; git push origin dev 开发完毕，要上线 1. 将dev分支合并到master，进行上线 git checkout master git merge dev git push origin master2. 把dev分支也推送到远程 git checkout dev git merge master git push origin dev 2.6.5 在公司约妹子忘记提交代码1. 拉代码 git pull origin dev 2. 继续开发3. 提交代码 git add . git commit -m &#x27;xx&#x27;注：忘记push了 2.6.6 回家继续写代码1. 拉代码，发现在公司写的代码忘记提交... git pull origin dev 2. 继续开发其他功能 3. 把dev分支也推送到远程 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.7 到公司继续写代码1. 拉代码，把晚上在家写的代码拉到本地(有合并、可能产生冲突) git pull origin dev 2. 如果有冲突，手动解决冲突 3. 继续开发其他功能 4. 把dev分支也推送到远程 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.8 其他git pull origin dev等价于git fetch origin devgit merge origin/dev 2.6.9 rebase的作用？rebase可以保持提交记录简洁，不分叉。 2.6.9 快速解决冲突 安装beyond compare 在git中配置 git config --local merge.tool bc3git config --local mergetool.path &#x27;/usr/local/bin/bcomp&#x27;git config --local mergetool.keepBackup false 应用beyond compare 解决冲突 git mergetool 2.7 小总结 添加远程连接（别名） git remote add origin 地址 推送代码 git push origin dev 下载代码 git clone 地址 拉取代码 git pull origin dev 等价于git fetch origin devgit merge origin/dev 保持代码提交整洁（变基） git rebase 分支 记录图形展示 git log --graph --pretty=format:&quot;%h %s&quot; 2.8 第六阶段：多人协同开发工作流 2.8.1 创建项目&amp;邀请成员协同开发时，需要所有成员都可以对同一个项目进行操作，需要邀请成员并赋予权限，否则无法开发。github支持两种创建项目的方式（供多人协同开发）。 合作者，将用户添加到仓库合作者中之后，该用户就可以向当前仓库提交代码。 组织，将成员邀请进入组织，组织下可以创建多个仓库，组织成员可以向组织下仓库提交代码。 扩展：Tag标签管理为了能清晰的管理版本，在公司不会直接使用commit来做版本，会基于Tag来实现：v1.0 、 v1.2 、v2.0 版本。 git tag -a v1.0 -m &#x27;版本介绍&#x27; 创建本地创建Tag信息git tag -d v1.0 删除Taggit push origin --tags 将本地tag信息推送到远程仓库git pull origin --tags 更新本地tag版本信息git checkout v.10 切换taggit clone -b v0.1 地址 指定tag下载代码 2.8.2 小弟开发 小弟注册Github 或 Gitlab账号 邀请小弟进入组织（默认对组织中的项目具有读权限） 邀请小弟成为某项目的合作者 小弟在自己电脑上下载代码并开发 git clone https://github.com/oldboy-org/dbhot.gitcd dbhotgit checkout devgit checkout -b dzz 写代码...git add .git commit -m &#x27;斗地主功能开发完成&#x27;git push origin ddz 2.8.3 code review 配置，代码review之后才能合并到dev分支。 小弟提交 code review申请 组长做 code review 2.8.4 提测上线（预发布）由专门团队或团队leader执行以下步骤： 基于dev分值创建release分值 git checkout devgit checkout -b release 测试等 合并到master 使用pull request或本地将release合并到master分支 在master分支打tag git tag -a v2 -m &#x27;第二版 斗地主功能&#x27;git push origin --tags 运维人员就可以去下载代码做上线了 git clone -b v2 地址 2.9 第七阶段：给开源软件贡献代码 fork源代码将别人源代码拷贝到我自己的远程仓库。 在自己仓库进行修改代码 给源代码的作者提交 修复bug的申请（pull request） 第三章 其他3.1 配置 项目配置文件：项目&#x2F;.git&#x2F;config git config --local user.name &#x27;武沛齐&#x27;git config --local user.email &#x27;wupeiqi@xx.com&#x27; 全局配置文件: ~&#x2F;.gitconfig git config --global user.name &#x27;wupeiq&#x27;git config --global user.name &#x27;wupeiqi@xx.com&#x27; 系统配置文件：&#x2F;etc&#x2F;.gitconfig git config --system user.name &#x27;wupeiq&#x27;git config --system user.name &#x27;wupeiqi@xx.com&#x27;注意：需要有root权限 应用场景： git config --local user.name &#x27;武沛齐&#x27;git config --local user.email &#x27;wupeiqi@xx.com&#x27;git config --local merge.tool bc3git config --local mergetool.path &#x27;/usr/local/bin/bcomp&#x27;git config --local mergetool.keepBackup falsegit remote add origin 地址 ，默认添加在本地配置文件中(--local) 3.2 免密码登录 URL中体现 原来的地址：https://github.com/WuPeiqi/dbhot.git修改的地址：https://用户名:密码@github.com/WuPeiqi/dbhot.gitgit remote add origin https://用户名:密码@github.com/WuPeiqi/dbhot.gitgit push origin master SSH实现 1. 生成公钥和私钥(默认放在 ~/.ssh目录下，id_rsa.pub公钥、id_rsa私钥） ssh-keygen2. 拷贝公钥的内容，并设置到github中。3. 在git本地中配置ssh地址 git remote add origin git@github.com:WuPeiqi/dbhot.git 4. 以后使用 git push origin master git自动管理凭证 3.3 git忽略文件让Git不再管理当前目录下的某些文件。 *.h!a.hfiles/*.py[c|a|d] 更多参考：https://github.com/github/gitignore 3.4 github任务管理相关 issues，文档以及任务管理。 wiki，项目文档。 结课感谢各位同学的关注和学习，希望git实战课程对你能够有所帮助，更多资源关注： 小猿圈 &lt;www.apeland.cn&gt; 路飞学城 &lt;www.luffycity.com&gt; 老男孩IT教育 &lt;www.oldboyedu.com&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","permalink":"https://wendy-ljw.github.io/tags/git/"}]},{"title":"原型与原型链","slug":"js-prototype","date":"2022-11-14T09:44:36.000Z","updated":"2022-11-15T12:44:39.251Z","comments":true,"path":"2022/11/14/js-prototype/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/14/js-prototype/","excerpt":"","text":"原型与原型链原型：被用于复制现有实例来生成新实例的函数 原型链：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。 构造函数：用new来调用，就是为了创建一个自定义类，构造函数和普通函数本质上没什么区别，只不过使用了new关键字创建对象的函数，被叫做了构造函数。 实例：是类在实例化之后一个一个具体的对象 原型JS中每一个函数都有一个prototype属性，这个属性指向函数的原型对象，每一个由原型对象派生的子对象，都有相同的属性。子对象就叫构造函数，从实例原型中获取相同的属性。 我们所创建的每一格函数，解析器都会向函数中添加一个属性prototype这个属性对应着一个对象，这个对象就是我们所谓的原型对象 打比方说： function Person(age) &#123; this.age = age &#125;Person.prototype.name = &#x27;ljw&#x27;var person1 = new Person()var person2 = new Person()console.log(person1.name) //ljwconsole.log(person2.name) //ljw 其中，函数的prototype指向了一个对象，而这个对象正是调用构造函数时创建的实例的原型，也就是person1和person2的原型。 _Proto __Proto _是每一个子对象（除null外）都会有的一个属性，指向该对象的原型 当函数以构造函数的形式调用时，它所创造的对象中都会有一个隐含的属性指向该构造函数的原型对象，我们可以通过_proto_来访问属性 function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 此属性可以访问原型，但并不存在于Person.prototype中，来自于Object.prototype,类似getter&#x2F;setter，即使用obj._proto_时，可以理解为返回Object.getPrototypeOf(obj) 构造函数constructor每个原型都有一个constructor属性，指向该关联的构造函数 如果函数作为普通函数调用prototype没有任何作用 function Person() &#123;&#125;console.log(Person===Person.prototype.constructor) //true function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层(也就是Object)为止。 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中 function Person() &#123;&#125;Person.prototype.name = &#x27;Kevin&#x27;;var person = new Person();person.name = &#x27;Daisy&#x27;;console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.proto ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 原型链原型对象也是对象，所以它也有原型，当我们使用一个对象的属性或方法时，会按照以下步骤： 先在自身中寻找 自身中如果有，则直接使用 如果自身中没有则去原型对象中寻找，如果原型对象中有，则使用 如果原型对象中没有，则去原型对象的原型对象中寻找，直到找到Object对象的原型 Object有原型，但Object的原型没有原型，如果在Object的原型里没有找到，则返回undefined 整个查找过程都是顺着__proto__属性，一步一步往上查找，形成了像链条一样的结构，这个结构，就是原型链。所以，原型链也叫作隐式原型链。 检查属性函数 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回trueconsole.log(&quot;name&quot; in person) //true 使用对象的hasOwnProperty()来检查对象自身中是否含有该属性，只有当对象自身中含有属性时，才会返回trueconsole.log(&quot;person.hasOwnProperty()&quot;) //false","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"}]},{"title":"Markdown使用指南","slug":"markdown","date":"2022-11-11T01:12:03.000Z","updated":"2022-11-15T12:44:59.085Z","comments":true,"path":"2022/11/11/markdown/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/11/markdown/","excerpt":"我的第一篇博客，从刚学来的markdown开始","text":"我的第一篇博客，从刚学来的markdown开始 标题1.分级标题&#x3D;&#x3D;&#x3D;&#x3D;上面一行的内容就是一级标题—-上面一行的内容就是二级标题&#x3D;&#x3D;&#x3D;&#x3D;或—-都要单独一行 这是一个一级标题============================这是一个二级标题---------------------------- 第二种写法用#放标题最前面，几个#表示是几级标题 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 2.斜体和粗体代码 *斜体*或_斜体_**粗体*****加粗斜体***~~删除线~~ 显示效果 这是一段斜体 这是一段粗体 这是一段加粗斜体 这是一段删除线 3.超链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 3.1 行内式 [链接名](链接地址 “链接的title属性”)链接的title属性可以不加 欢迎来到[重庆理工大学](https://www.cqut.edu.cn/)欢迎来到[重庆理工大学](https://www.cqut.edu.cn/ &quot;重庆理工大学&quot;) 显示效果 欢迎来到重庆理工大学 欢迎来到重庆理工大学 3.2 参考式 利用变量的形式&#x2F;[链接名][链接变量名] 一般用在学术论文上 当某个链接在文章中多处使用的时候，也可以使用参考式超链接，会很方便 比如说[CQUT][1]、[Google][g][1]:https://www.cqut.edu.cn &quot;CQUT&quot;[g]:http://www.google.com &quot;Google&quot; 显示效果 比如说CQUT、Google 3.3 自动连接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。 &lt;https://www.cqut.edu.cn/&gt; 显示效果 https://www.cqut.edu.cn/ 4.列表4.1 无序列表使用 *，+，- 表示无序列表。 - 哈哈- 嘿嘿- 嘻嘻 显示效果 哈哈 嘿嘿 嘻嘻 4.2 有序列表有序列表则使用数字接着一个英文句点。 1. 嘿嘿2. 哈哈3. 嘻嘻 显示效果 嘿嘿 哈哈 嘻嘻 4.3 列表缩进- 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！- 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 4.4 包含段落的列表* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ * 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 4.5 列表嵌套* 无序1 1. 有序1 2. 有序2 - 无序3 3. 有序3* 无序2 - 无序4 显示效果 无序1 有序1 有序2 无序3 有序3 无序2 无序4 5.区块引用&gt;这是一个区块引用 显示效果 这是一个区块引用 还可嵌套引用 5.1 嵌套列表&gt;- 嵌套无序列表&gt;- haha&gt;1. 嵌套有序列表&gt;2.xixi 显示效果 嵌套无序列表 haha 嵌套有序列表 xixi 5.2 嵌套代码&gt;代码&gt;&gt; return 0; 显示效果 代码 return 0; 6.图像与超链接用法相似 6.1 行内式![花花](http://xtzl.wentexl.cn/ljw/bjt/b0002.jpg) 显示效果 6.2 参考式![花花][f][f]:http://xtzl.wentexl.cn/ljw/bjt/b0002.jpg &quot;花花&quot; 显示效果 7.注脚在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。[^1]:Markdown是一种纯文本标记语言[^2]:HyperTextMarkupLanguage超文本标记语言[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文 显示效果 使用 Markdown^1可以效率的书写文档, 直接转换成 HTML^2, 你可以使用 Leanote^Le 编辑器进行书写。 8.引用公式$表示行内公式 $$表示整行公式 一元二次方程$y=ax^2+bx+c$ 显示效果 一元二次方程$y&#x3D;ax^2+bx+c$ $$y=ax^2+bx+c$$$$x=x+1$$ 显示效果$$y&#x3D;ax^2+bx+c$$$$x&#x3D;x+1$$ 9.表格 不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。普通格式|表头|表头||-|-||1|单元格||2|表格|简单格式|表头|表头|-|-|1|单元格||2|表格|对齐|左对齐|右对齐|居中对齐|:-|-:|:-:|1|单元格|表格||2|表格|单元格| 显示效果 普通格式 表头 表头 1 单元格 2 表格 简单格式 表头 表头 1 单元格 2 表格 对齐 左对齐 右对齐 居中对齐 1 单元格 表格 2 表格 单元格 10.分隔线用三个及以上的*-_以及空格组成，显示效果都一样 **** * ******- - ----------- 显示效果 11.代码对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”&#96;”符号（一般在ESC键下方）包裹代码。 11.1 行内式记得`return 0` 显示效果 记得return 0 11.2 多行代码利用缩进或者是用&#96;&#96;&#96;&#96;&#96;&#96;包裹代码 #include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;Hello world\\n&quot;);&#125; 显示效果 #include &lt;stdio.h&gt; int main(void) &#123; printf(&quot;Hello world\\n&quot;); &#125; 11.3 直接引用HTML&lt;div&gt;这是一个块&lt;/div&gt; 显示效果 这是一个块 11.4 转义引用可以用反斜杠打印特殊符号，如： \\ 反斜线` 反引号* 星号_ 下划线&#123;&#125; 花括号[] 方括号() 小括号# 井字号+ 加号- 减号. 英文句点! 感叹号","categories":[{"name":"总结","slug":"总结","permalink":"https://wendy-ljw.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://wendy-ljw.github.io/tags/markdown/"}]},{"title":"文章演示页面","slug":"post-example","date":"2021-07-24T16:00:00.000Z","updated":"2022-11-15T12:46:09.348Z","comments":true,"path":"2021/07/25/post-example/","link":"","permalink":"https://wendy-ljw.github.io/2021/07/25/post-example/","excerpt":"显示在首页的内容","text":"显示在首页的内容 一级标题二级标题三级标题四级标题瀑布流图片 相片集 字符效果和横线等 删除线斜体字 斜体字粗体 粗体粗斜体 粗斜体 上标：X2，下标：O2 缩写(同HTML的abbr标签) 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启 The HTML specification is maintained by the W3C. 引用 Blockquotes 引用文本 Blockquotes 锚点与链接 Links普通链接 普通链接带描述 直接链接：https://github.com 多语言代码高亮 Codes行内代码 Inline code执行命令：npm install marked JS代码function test()&#123; console.log(&quot;Hello world!&quot;);&#125; (function()&#123; var box = function()&#123; return box.fn.init(); &#125;; box.prototype = box.fn = &#123; init : function()&#123; console.log(&#x27;box.init()&#x27;); return this; &#125;, add : function(str)&#123; alert(&quot;add&quot;, str); return this; &#125;, remove : function(str)&#123; alert(&quot;remove&quot;, str); return this; &#125; &#125;; box.fn.init.prototype = box.fn; window.box =box;&#125;)();var testBox = box();testBox.add(&quot;jQuery&quot;).remove(&quot;jQuery&quot;); HTML代码 HTML codes&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest=&quot;utf-8&quot; /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello world!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 图片 Images 图片加链接 (Image + Link)： 列表 Lists无序列表 列表一 列表二 列表二-1 列表二-2 列表二-3 列表三 列表一 列表二 列表三 有序列表 第一行 第二行 第三行 GFM task list GFM task list 1 GFM task list 2 GFM task list 3 GFM task list 3-1 GFM task list 3-2 GFM task list 3-3 GFM task list 4 GFM task list 4-1 GFM task list 4-2 绘制表格 Tables 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234","categories":[{"name":"种类","slug":"种类","permalink":"https://wendy-ljw.github.io/categories/%E7%A7%8D%E7%B1%BB/"}],"tags":[{"name":"标签","slug":"标签","permalink":"https://wendy-ljw.github.io/tags/%E6%A0%87%E7%AD%BE/"}]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"总结","slug":"总结","permalink":"https://wendy-ljw.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"种类","slug":"种类","permalink":"https://wendy-ljw.github.io/categories/%E7%A7%8D%E7%B1%BB/"}],"tags":[{"name":"git","slug":"git","permalink":"https://wendy-ljw.github.io/tags/git/"},{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"},{"name":"markdown","slug":"markdown","permalink":"https://wendy-ljw.github.io/tags/markdown/"},{"name":"标签","slug":"标签","permalink":"https://wendy-ljw.github.io/tags/%E6%A0%87%E7%AD%BE/"}]}