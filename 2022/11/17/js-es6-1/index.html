<!DOCTYPE html>

<html lang="zh-CN">

<head>
    
    <title>js高级-es6笔记 - Wendy</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/assets/tx0001.png" type="image/png" />
    <meta name="description" content="JavaScript 进阶 - 第1天 学习作用域、变量提升、闭包等语言特征，加深对 JavaScript 的理解，掌握变量赋值、函数声明的简洁语法，降低代码的冗余度。   理解作用域对程序执行的影响 能够分析程序执行的作用域范围 理解闭包本质，利用闭包创建隔离作用域 了解什么变量提升及函数提升 掌握箭头函数、解析剩余参数等简洁语法  一、作用域 了解作用域对程序执行的影响及作用域链的查找机制，使">
<meta property="og:type" content="article">
<meta property="og:title" content="js高级-es6笔记">
<meta property="og:url" content="https://wendy-ljw.github.io/2022/11/17/js-es6-1/index.html">
<meta property="og:site_name" content="Wendy">
<meta property="og:description" content="JavaScript 进阶 - 第1天 学习作用域、变量提升、闭包等语言特征，加深对 JavaScript 的理解，掌握变量赋值、函数声明的简洁语法，降低代码的冗余度。   理解作用域对程序执行的影响 能够分析程序执行的作用域范围 理解闭包本质，利用闭包创建隔离作用域 了解什么变量提升及函数提升 掌握箭头函数、解析剩余参数等简洁语法  一、作用域 了解作用域对程序执行的影响及作用域链的查找机制，使">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wendy-ljw.github.io/assets/scope.png">
<meta property="article:published_time" content="2022-11-17T02:35:20.000Z">
<meta property="article:modified_time" content="2022-11-17T07:53:33.983Z">
<meta property="article:author" content="Wendy">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="es6">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wendy-ljw.github.io/assets/scope.png">
    <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css"
    />
    <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"
    />
    
        <link rel="stylesheet" href="//at.alicdn.com/t/c/font_3763712_by4sjqrtp9w.css">
    
    <link rel="stylesheet" href="/lib/mdui_043tiny/css/mdui.css?v=1668672300522">
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1668672300522">
    <link rel="stylesheet" href="/css/style.css?v=1668672300522">
     
    
        <link rel="stylesheet" href="/custom.css">
    
<meta name="generator" content="Hexo 6.0.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(/assets/bjt/b0001.jpg)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="Wendy" class="mdui-btn mdui-btn-icon"><img src="/assets/tx0001.png" alt="Wendy"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Wendy">
            <img src="/assets/tx0001.png" alt="Wendy" alt="Wendy">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>5</div>
        <div><span>标签</span>5</div>
        <div><span>分类</span>4</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://onlineweb.zhihuishu.com/onlinestuh5" target="_blank" mdui-tooltip="{content: '智慧树'}" style="color: rgb(60,179,113);background-color: rgba(60,179,113,.15);">
            <i class="nexmoefont icon-tree"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/107170390" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/Wendy-ljw/wendy-ljw.github.io" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a><a class="mdui-ripple" href="https://www.cqut.edu.cn/" target="_blank" mdui-tooltip="{content: 'CQUT'}" style="color: rgb(68,206,246);background-color: rgba(68,206,246,.15);">
            <i class="nexmoefont icon-home"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/note/">note</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/总结/">总结</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/种类/">种类</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/笔记/">笔记</a>
          <span class="category-list-count">2</span>
        </li>

        
      </ul>

    </div>
  </div>


    
    
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/es6/" style="font-size: 10px;">es6</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/%E6%A0%87%E7%AD%BE/" style="font-size: 10px;">标签</a>
    </div>
    
  </div>

    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 Wendy
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br><script data-ad-client="ca-pub-2058306854838448" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 56.25%;"> 
              <img data-fancybox="gallery" src="/assets/bjt/b0001.jpg" alt="js高级-es6笔记" loading="lazy">
              <h1>js高级-es6笔记</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年11月17日</a>
</div>

      <h2 id="JavaScript-进阶-第1天"><a href="#JavaScript-进阶-第1天" class="headerlink" title="JavaScript 进阶 - 第1天"></a>JavaScript 进阶 - 第1天</h2><blockquote>
<p>学习作用域、变量提升、闭包等语言特征，加深对 JavaScript 的理解，掌握变量赋值、函数声明的简洁语法，降低代码的冗余度。</p>
</blockquote>
<ul>
<li>理解作用域对程序执行的影响</li>
<li>能够分析程序执行的作用域范围</li>
<li>理解闭包本质，利用闭包创建隔离作用域</li>
<li>了解什么变量提升及函数提升</li>
<li>掌握箭头函数、解析剩余参数等简洁语法</li>
</ul>
<h3 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h3><blockquote>
<p>了解作用域对程序执行的影响及作用域链的查找机制，使用闭包函数创建隔离作用域避免全局变量污染。</p>
</blockquote>
<p>作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问，作用域分为<strong>全局作用域</strong>和<strong>局部作用域</strong>。</p>
<h4 id="1-1-局部作用域"><a href="#1-1-局部作用域" class="headerlink" title="1.1 局部作用域"></a>1.1 局部作用域</h4><p>局部作用域分为函数作用域和块作用域。</p>
<h5 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h5><p>在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 声明 counter 函数</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counter</span>(<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-comment">// 函数内部声明的变量</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> s = x + y</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(s) <span class="hljs-comment">// 18</span></span><br><span class="javascript">  &#125;</span><br><span class="javascript">  <span class="hljs-comment">// 设用 counter 函数</span></span><br><span class="javascript">  counter(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>)</span><br><span class="javascript">  <span class="hljs-comment">// 访问变量 s</span></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(s)<span class="hljs-comment">// 报错</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>函数内部声明的变量，在函数外部无法被访问</li>
<li>函数的参数也是函数内部的局部变量</li>
<li>不同函数内部声明的变量无法互相访问</li>
<li>函数执行完毕后，函数内部的变量实际被清空了</li>
</ol>
<h5 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h5><p>在 JavaScript 中使用 <code>&#123;&#125;</code> 包裹的代码称为代码块，代码块内部声明的变量外部将<strong>有可能</strong>无法被访问。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  &#123;</span><br><span class="javascript">    <span class="hljs-comment">// age 只能在该代码块中被访问</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> age = <span class="hljs-number">18</span>;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// 正常</span></span><br><span class="javascript">  &#125;</span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-comment">// 超出了 age 的作用域</span></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(age) <span class="hljs-comment">// 报错</span></span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;</span><br><span class="javascript">  <span class="hljs-keyword">if</span>(flag) &#123;</span><br><span class="javascript">    <span class="hljs-comment">// str 只能在该代码块中被访问</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world!&#x27;</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(str); <span class="hljs-comment">// 正常</span></span><br><span class="javascript">  &#125;</span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-comment">// 超出了 str 的作用域</span></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(str); <span class="hljs-comment">// 报错</span></span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> t = <span class="hljs-number">1</span>; t &lt;= <span class="hljs-number">6</span>; t++) &#123;</span><br><span class="javascript">    <span class="hljs-comment">// t 只能在该代码块中被访问</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(t); <span class="hljs-comment">// 正常</span></span><br><span class="javascript">  &#125;</span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-comment">// 超出了 t 的作用域</span></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(t); <span class="hljs-comment">// 报错</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>JavaScript 中除了变量外还有常量，常量与变量本质的区别是<strong>常量必须要有值且不允许被重新赋值</strong>，常量值为对象时其属性和方法允许重新赋值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 必须要有值</span></span><br><span class="javascript">  <span class="hljs-keyword">const</span> version = <span class="hljs-string">&#x27;1.0.0&#x27;</span>;</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 不能重新赋值</span></span><br><span class="javascript">  <span class="hljs-comment">// version = &#x27;1.0.1&#x27;;</span></span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 常量值为对象类型</span></span><br><span class="javascript">  <span class="hljs-keyword">const</span> user = &#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span></span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 不能重新赋值</span></span><br><span class="javascript">  user = &#123;&#125;;</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 属性和方法允许被修改</span></span><br><span class="javascript">  user.name = <span class="hljs-string">&#x27;小小明&#x27;</span>;</span><br><span class="javascript">  user.gender = <span class="hljs-string">&#x27;男&#x27;</span>;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><code>let</code> 声明的变量会产生块作用域，<code>var</code> 不会产生块作用域</li>
<li><code>const</code> 声明的常量也会产生块作用域</li>
<li>不同代码块之间的变量无法互相访问</li>
<li>推荐使用 <code>let</code> 或 <code>const</code></li>
</ol>
<p>注：开发中 <code>let</code> 和 <code>const</code> 经常不加区分的使用，如果担心某个值会不小被修改时，则只能使用 <code>const</code> 声明成常量。</p>
<h4 id="1-2-全局作用域"><a href="#1-2-全局作用域" class="headerlink" title="1.2 全局作用域"></a>1.2 全局作用域</h4><p><code>&lt;script&gt;</code> 标签和 <code>.js</code> 文件的<strong>最外层</strong>就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 此处是全局</span></span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-comment">// 此处为局部</span></span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 此处为全局</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>全局作用域中声明的变量，任何其它作用域都可以被访问，如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">// 全局变量 name</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;小明&#x27;</span></span><br><span class="javascript">  </span><br><span class="javascript">  	<span class="hljs-comment">// 函数作用域中访问全局</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-comment">// 此处为局部</span></span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你好&#x27;</span> + name)</span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">// 全局变量 flag 和 x</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> flag = <span class="hljs-literal">true</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span></span><br><span class="javascript">  </span><br><span class="javascript">  	<span class="hljs-comment">// 块作用域中访问全局</span></span><br><span class="javascript">    <span class="hljs-keyword">if</span>(flag) &#123;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> y = <span class="hljs-number">5</span></span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(x + y) <span class="hljs-comment">// x 是全局的</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>为 <code>window</code> 对象动态添加的属性默认也是全局的，不推荐！</li>
<li>函数中未使用任何关键字声明的变量为全局变量，不推荐！！！</li>
<li>尽可能少的声明全局变量，防止全局变量被污染</li>
</ol>
<p>JavaScript 中的作用域是程序被执行时的底层机制，了解这一机制有助于规范代码书写习惯，避免因作用域导致的语法错误。</p>
<h4 id="1-3-作用域链"><a href="#1-3-作用域链" class="headerlink" title="1.3 作用域链"></a>1.3 作用域链</h4><p>在解释什么是作用域链前先来看一段代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 全局作用域</span></span><br><span class="javascript">  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span></span><br><span class="javascript">  <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span></span><br><span class="javascript">  <span class="hljs-comment">// 局部作用域</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> c</span><br><span class="javascript">    <span class="hljs-comment">// 局部作用域</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> d = <span class="hljs-string">&#x27;yo&#x27;</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>函数内部允许创建新的函数，<code>f</code> 函数内部创建的新函数 <code>g</code>，会产生新的函数作用域，由此可知作用域产生了嵌套的关系。</p>
<p>如下图所示，父子关系的作用域关联在一起形成了链状的结构，作用域链的名字也由此而来。</p>
<p><img data-fancybox="gallery" src="/./assets/scope.png" alt="scope" data-caption="scope" loading="lazy"></p>
<p>作用域链<em>本质</em>上是底层的<strong>变量查找机制</strong>，在函数被执行时，会<strong>优先查找当前</strong>函数作用域中查找变量，如果当前作用域查找不到则会依次<strong>逐级查找父级作用域</strong>直到全局作用域，如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 全局作用域</span></span><br><span class="javascript">  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span></span><br><span class="javascript">  <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span></span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 局部作用域</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> c</span><br><span class="javascript">    <span class="hljs-comment">// let a = 10;</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// 1 或 10</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(d) <span class="hljs-comment">// 报错</span></span><br><span class="javascript">    </span><br><span class="javascript">    <span class="hljs-comment">// 局部作用域</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> d = <span class="hljs-string">&#x27;yo&#x27;</span></span><br><span class="javascript">      <span class="hljs-comment">// let b = 20;</span></span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// 2 或 20</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">    </span><br><span class="javascript">    <span class="hljs-comment">// 调用 g 函数</span></span><br><span class="javascript">    g()</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(c) <span class="hljs-comment">// 报错</span></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(d) <span class="hljs-comment">// 报错</span></span><br><span class="javascript">  </span><br><span class="javascript">  f();</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>嵌套关系的作用域串联起来形成了作用域链</li>
<li>相同作用域链中按着从小到大的规则查找变量</li>
<li>子作用域能够访问父作用域，父级作用域无法访问子级作用域</li>
</ol>
<h4 id="1-4-垃圾回收机制"><a href="#1-4-垃圾回收机制" class="headerlink" title="1.4 垃圾回收机制"></a>1.4 垃圾回收机制</h4><h5 id="1-4-1-什么是垃圾回收机制？"><a href="#1-4-1-什么是垃圾回收机制？" class="headerlink" title="1.4.1 什么是垃圾回收机制？"></a>1.4.1 什么是垃圾回收机制？</h5><p>垃圾回收机制（Garbage Collection) 简称 GC<br>JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器<strong>自动回收</strong>  </p>
<h4 id="1-4-2-内存泄漏"><a href="#1-4-2-内存泄漏" class="headerlink" title="1.4.2 内存泄漏"></a>1.4.2 内存泄漏</h4><p>正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题<br>但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法回收）的情况<br>不再用到的内存，没有及时释放，就叫做<strong>内存泄漏</strong>  </p>
<h4 id="1-4-3-内存的生命周期"><a href="#1-4-3-内存的生命周期" class="headerlink" title="1.4.3 内存的生命周期"></a>1.4.3 内存的生命周期</h4><p>JS环境中分配的内存，一般有如下生命周期：</p>
<ol>
<li>内存分配： 当我们声明变量、函数、对象的时候，系统会自动为他们分配内存</li>
<li>内存使用： 即读写内存，也就是使用变量、函数等</li>
<li>内存回收： 使用完毕，由垃圾回收自动回收不再使用的内容</li>
<li>说明： <ul>
<li>全局变量一般不会回收（关闭页面回收）；</li>
<li>一般情况下局部变量的值，不用了会被自动回收掉</li>
</ul>
</li>
</ol>
<h4 id="1-4-4-垃圾回收算法说明"><a href="#1-4-4-垃圾回收算法说明" class="headerlink" title="1.4.4 垃圾回收算法说明"></a>1.4.4 垃圾回收算法说明</h4><p>所谓垃圾回收，核心思想就是如何判断内存是否已经不再会被使用了，如果是，就视为垃圾，释放掉<br>有两种常见的浏览器垃圾回收算法： <strong>引用计数法</strong>和<strong>标记清除法</strong></p>
<p><em><strong>引用计数</strong></em><br>IE采用的引用计数算法，定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。<br>算法：</p>
<ol>
<li>跟踪记录每个值被引用的次数。</li>
<li>如果这个值的被引用了一次，那么就记录次数加1</li>
<li>多次引用会累加</li>
<li>如果减少一个引用就减1</li>
<li>如果引用次数是0，则释放内存<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">const</span> person=&#123; <span class="hljs-comment">//定义了person，引用次数为1</span></span><br><span class="javascript">        <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>,</span><br><span class="javascript">        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;ljw&#x27;</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">    <span class="hljs-keyword">const</span> p=person  <span class="hljs-comment">//因为引用的是地址，所以引用次数加一</span></span><br><span class="javascript">    person=<span class="hljs-number">1</span>  <span class="hljs-comment">//person不再指向原来的结构体，所以引用次数减一</span></span><br><span class="javascript">    p=<span class="hljs-literal">null</span>   <span class="hljs-comment">//p也不再指向原来的结构体，所以引用次数减一</span></span><br><span class="javascript">    <span class="hljs-comment">//此时引用次数为0，释放内存</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
由上面可以看出，引用计数算法是个简单有效的算法。<br>但它却存在一个致命的问题：<strong>嵌套引用</strong><br>如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄漏。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> o1 = &#123;&#125;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> o2 = &#123;&#125;</span><br><span class="javascript">        o1.a = o2</span><br><span class="javascript">        o2.a = o1</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;引用计数无法回收&#x27;</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">    fn()</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>因为他们的引用次数永远不会是0，这样的相互引用如果很大量的存在就会导致大量的内存泄漏</p>
<p><em><strong>标记清除法</strong></em></p>
<p>现在的浏览器已经不再使用引用计数算法了。<br>现在浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。<br>核心：</p>
<ol>
<li>标记清除算法将“不再使用的对象”定义为“无法达到的对象”</li>
<li>就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。</li>
<li>那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收</li>
</ol>
<h4 id="1-5-闭包"><a href="#1-5-闭包" class="headerlink" title="1.5 闭包"></a>1.5 闭包</h4><p>闭包（closure）是一种比较特殊和函数，使用闭包能够访问函数作用域中的变量。<br>一个函数对周围状态的引用<strong>捆绑</strong>在一起，内层函数中访问到其外层函数的作用域</p>
<blockquote>
<p>闭包&#x3D;内层函数+外层函数的变量</p>
</blockquote>
<p>从代码形式上看闭包是一个做为返回值的函数，如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">// 函数内部分函数</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">			<span class="hljs-built_in">console</span>.log(++i);</span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">// 将函数做为返回值</span></span><br><span class="javascript">    <span class="hljs-keyword">return</span> bar;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-comment">// fn 即为闭包函数</span></span><br><span class="javascript">  <span class="hljs-keyword">let</span> fn = foo();</span><br><span class="javascript">  </span><br><span class="javascript">  fn(); <span class="hljs-comment">// 1</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>常见闭包的形式：外部可以访问使用函数内部的变量</p>
</blockquote>
<p>总结：</p>
<ol>
<li>闭包本质仍是函数，只不是从函数内部返回的</li>
<li>闭包能够创建外部可访问的隔离作用域，避免全局变量污染</li>
<li>过度使用闭包可能造成内存泄漏</li>
</ol>
<p>注：回调函数也能访问函数内部的局部变量。</p>
<h4 id="1-6-变量提升"><a href="#1-6-变量提升" class="headerlink" title="1.6 变量提升"></a>1.6 变量提升</h4><p>变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问。  </p>
<blockquote>
<p>把所有var声明的变量提升到当前作用域的最前面，只提升声明，不提升赋值</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 访问变量 str</span></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(str + <span class="hljs-string">&#x27;world!&#x27;</span>);</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 声明变量 str</span></span><br><span class="javascript">  <span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;hello &#x27;</span>;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>变量在未声明即被访问时会报语法错误</li>
<li>变量在声明之前即被访问，变量的值为 <code>undefined</code></li>
<li><code>let</code> 声明的变量不存在变量提升，推荐使用 <code>let</code></li>
<li>变量提升出现在相同作用域当中</li>
<li>实际开发中推荐先声明再访问变量</li>
</ol>
<p>注：关于变量提升的原理分析会涉及较为复杂的词法分析等知识，而开发中使用 <code>let</code> 可以轻松规避变量的提升，因此在此不做过多的探讨，有兴趣可<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013915935">查阅资料</a>。</p>
<h3 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h3><blockquote>
<p>知道函数参数默认值、动态参数、剩余参数的使用细节，提升函数应用的灵活度，知道箭头函数的语法及与普通函数的差异。</p>
</blockquote>
<h4 id="2-1-函数提升"><a href="#2-1-函数提升" class="headerlink" title="2.1 函数提升"></a>2.1 函数提升</h4><p>函数提升与变量提升比较类似，是指函数在声明之前即可被调用。</p>
<blockquote>
<p>会把所有函数声明提升到当前作用域的最前面<br>只提升函数声明，不提升函数调用</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 调用函数 </span></span><br><span class="javascript">  foo()</span><br><span class="javascript">  <span class="hljs-comment">// 声明函数</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;声明之前即被调用...&#x27;</span>)</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 不存在提升现象</span></span><br><span class="javascript">  bar()  <span class="hljs-comment">// 错误</span></span><br><span class="javascript">  <span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;   <span class="hljs-comment">//因为变量被提升了，但是函数赋值没有被提升</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;函数表达式不存在提升现象...&#x27;</span>)</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>函数提升能够使函数的声明调用更灵活</li>
<li>函数表达式不存在提升的现象</li>
<li>函数提升出现在相同作用域当中</li>
</ol>
<h4 id="2-2-参数"><a href="#2-2-参数" class="headerlink" title="2.2 参数"></a>2.2 参数</h4><p>函数参数的使用细节，能够提升函数应用的灵活度。</p>
<h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 设置参数默认值</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">name=<span class="hljs-string">&quot;小明&quot;</span>, age=<span class="hljs-number">18</span></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">`&lt;p&gt;大家好，我叫<span class="hljs-subst">$&#123;name&#125;</span>，我今年<span class="hljs-subst">$&#123;age&#125;</span>岁了。&lt;/p&gt;`</span>);</span><br><span class="javascript">  &#125;</span><br><span class="javascript">  <span class="hljs-comment">// 调用函数</span></span><br><span class="javascript">  sayHi();</span><br><span class="javascript">  sayHi(<span class="hljs-string">&#x27;小红&#x27;</span>);</span><br><span class="javascript">  sayHi(<span class="hljs-string">&#x27;小刚&#x27;</span>, <span class="hljs-number">21</span>);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>声明函数时为形参赋值即为参数的默认值</li>
<li>如果参数未自定义默认值时，参数的默认值为 <code>undefined</code></li>
<li>调用函数时没有传入对应实参时，参数的默认值被当做实参传入</li>
</ol>
<h5 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h5><p><code>arguments</code> 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 求生函数，计算所有参数的和</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-comment">// console.log(arguments)</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> s = <span class="hljs-number">0</span></span><br><span class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) &#123;</span><br><span class="javascript">      s += <span class="hljs-built_in">arguments</span>[i]</span><br><span class="javascript">    &#125;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(s)</span><br><span class="javascript">  &#125;</span><br><span class="javascript">  <span class="hljs-comment">// 调用求和函数</span></span><br><span class="javascript">  sum(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<span class="hljs-comment">// 两个参数</span></span><br><span class="javascript">  sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// 两个参数</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><code>arguments</code> 是一个伪数组</li>
<li><code>arguments</code> 的作用是动态获取函数的实参</li>
</ol>
<h5 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h5><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">config</span>(<span class="hljs-params">baseURL, ...other</span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(baseURL) <span class="hljs-comment">// 得到 &#x27;http://baidu.com&#x27;</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(other)  <span class="hljs-comment">// other  得到 [&#x27;get&#x27;, &#x27;json&#x27;]</span></span><br><span class="javascript">  &#125;</span><br><span class="javascript">  <span class="hljs-comment">// 调用函数</span></span><br><span class="javascript">  config(<span class="hljs-string">&#x27;http://baidu.com&#x27;</span>, <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;json&#x27;</span>);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><code>...</code> 是语法符号，置于最末函数形参之前，用于获取多余的实参</li>
<li>借助 <code>...</code> 获取的剩余实参，是个真数组</li>
</ol>
<h5 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h5><p>展开运算符（…），将一个数组进行展开</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-built_in">console</span>.log(...arr) <span class="hljs-comment">// 1 2 3 4 5</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>不会改变原数组</p>
</blockquote>
<p>典型运用场景：求数组最大值（最小值）、合并数组等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//求最值</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.max(...arr))<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.min(...arr))<br><span class="hljs-comment">//合并数组</span><br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">const</span> arr = [...arr1,...arr2]<br></code></pre></td></tr></table></figure>
<p>展开运算符的剩余参数的区别：<br>剩余参数：函数参数使用，得到真数组<br>展开运算符：数组中使用，数组展开</p>
<h4 id="2-3-箭头函数"><a href="#2-3-箭头函数" class="headerlink" title="2.3 箭头函数"></a>2.3 箭头函数</h4><p>箭头函数是一种声明函数的简洁语法，它与普通函数并无本质的区别，差异性更多体现在语法格式上。</p>
<blockquote>
<p>引入箭头函数的目的是更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁<br>箭头函数更适用于那些本来需要匿名函数的地方</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 箭头函数</span></span><br><span class="javascript">  <span class="hljs-keyword">const</span> foo = <span class="hljs-function">() =&gt;</span> &#123;       <span class="hljs-comment">//本行相当于 const foo = function () &#123;</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;^_^ 长相奇怪的函数...&#x27;</span>);</span><br><span class="javascript">  &#125;</span><br><span class="javascript">  <span class="hljs-comment">// 调用函数</span></span><br><span class="javascript">  foo()</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">//只有一个参数时可以省略圆括号 ()</span></span><br><span class="javascript">  <span class="hljs-keyword">const</span> fn = <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(a)</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">//函数体只有一行代码时可以省略花括号 `&#123;&#125;`，并自动做为返回值被返回</span></span><br><span class="javascript">  <span class="hljs-keyword">const</span> fn = <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a + a</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 更简洁的语法 </span></span><br><span class="javascript">  <span class="hljs-keyword">const</span> form = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;form&#x27;</span>)</span><br><span class="javascript">  form.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">ev</span> =&gt;</span> ev.preventDefault())</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">//可以直接返回一个对象</span></span><br><span class="javascript">  <span class="hljs-keyword">const</span> fn = <span class="hljs-function">(<span class="hljs-params">uname</span>) =&gt;</span> (&#123; <span class="hljs-attr">uname</span>: uname &#125;)</span><br><span class="javascript"></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>箭头函数中的this</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以前this的指向：  谁调用的这个函数，this 就指向谁</span><br> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)  <span class="hljs-comment">// window</span><br> <span class="hljs-comment">// 普通函数</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)  <span class="hljs-comment">// window</span><br> &#125;<br> <span class="hljs-built_in">window</span>.fn()<br> <span class="hljs-comment">// 对象方法里面的this</span><br> <span class="hljs-keyword">const</span> obj = &#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;andy&#x27;</span>,<br>   <span class="hljs-attr">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)  <span class="hljs-comment">// obj</span><br>   &#125;<br> &#125;<br> obj.sayHi()<br><br><span class="hljs-comment">// 2. 箭头函数的this  是上一层作用域的this 指向</span><br> <span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)  <span class="hljs-comment">// window</span><br> &#125;<br> fn()<br><span class="hljs-comment">// 对象方法箭头函数 this</span><br> <span class="hljs-keyword">const</span> obj = &#123;<br>   <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;pink老师&#x27;</span>,<br>   <span class="hljs-attr">sayHi</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)  <span class="hljs-comment">// this 指向谁？ window</span><br>   &#125;<br> &#125;<br> obj.sayHi()<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;pink老师&#x27;</span>,<br>  <span class="hljs-attr">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)  <span class="hljs-comment">// obj</span><br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">const</span> count = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)  <span class="hljs-comment">// obj </span><br>    &#125;<br>    count()<br>  &#125;<br>&#125;<br>obj.sayHi()<br></code></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>箭头函数属于表达式函数，因此不存在函数提升</li>
<li>箭头函数只有一个参数时可以省略圆括号 <code>()</code></li>
<li>箭头函数函数体只有一行代码时可以省略花括号 <code>&#123;&#125;</code>，并自动做为返回值被返回</li>
<li>箭头函数中没有 <code>arguments</code>，只能使用剩余函数 <code>...</code> 动态获取实参</li>
<li>箭头函数不会创建自己的this,它只会从自己的作用域链的上一层延用this</li>
<li>DOM事件回调函数不推荐使用箭头函数，特别是要用到this的时候</li>
<li>事件回调函数使用箭头函数时，this为全局的window</li>
</ol>
<h3 id="三、解构赋值"><a href="#三、解构赋值" class="headerlink" title="三、解构赋值"></a>三、解构赋值</h3><blockquote>
<p>知道解构的语法及分类，使用解构简洁语法快速为变量赋值。</p>
</blockquote>
<p>解构赋值是一种快速为变量赋值的简洁语法，本质上仍然是为变量赋值，分为数组解构、对象解构两大类型。</p>
<h4 id="3-1-数组解构"><a href="#3-1-数组解构" class="headerlink" title="3.1 数组解构"></a>3.1 数组解构</h4><p>数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法，如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 普通的数组</span></span><br><span class="javascript">  <span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br><span class="javascript">  <span class="hljs-comment">// 批量声明变量 a b c </span></span><br><span class="javascript">  <span class="hljs-comment">// 同时将数组单元值 1 2 3 依次赋值给变量 a b c</span></span><br><span class="javascript">  <span class="hljs-keyword">let</span> [a, b, c] = arr;</span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 2</span></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// 3</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p>总结：</p>
<ol>
<li>赋值运算符 <code>=</code> 左侧的 <code>[]</code> 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量</li>
<li>变量的顺序对应数组单元值的位置依次进行赋值操作</li>
<li>变量的数量大于单元值数量时，多余的变量将被赋值为  <code>undefined</code></li>
<li>变量的数量小于单元值数量时，可以通过 <code>...</code> 获取剩余单元值，但只能置于最末位</li>
<li>允许初始化变量的默认值，且只有单元值为 <code>undefined</code> 时默认值才会生效</li>
</ol>
<p>注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析</p>
<h4 id="3-2-对象解构"><a href="#3-2-对象解构" class="headerlink" title="3.2 对象解构"></a>3.2 对象解构</h4><p>对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法，如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 普通对象</span></span><br><span class="javascript">  <span class="hljs-keyword">const</span> user = &#123;</span><br><span class="javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span></span><br><span class="javascript">  &#125;;</span><br><span class="javascript">  <span class="hljs-comment">// 批量声明变量 name age</span></span><br><span class="javascript">  <span class="hljs-comment">// 同时将数组单元值 小明  18 依次赋值给变量 name  age</span></span><br><span class="javascript">  <span class="hljs-keyword">const</span> &#123;name, age&#125; = user</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(name) <span class="hljs-comment">// 小明</span></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(age) <span class="hljs-comment">// 18</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>赋值运算符 <code>=</code> 左侧的 <code>&#123;&#125;</code> 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量</li>
<li>对象属性的值将被赋值给与属性名相同的变量</li>
<li>对象中找不到与变量名一致的属性时变量值为 <code>undefined</code></li>
<li>允许初始化变量的默认值，属性不存在或单元值为 <code>undefined</code> 时默认值才会生效</li>
</ol>
<p>注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析</p>

  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>本文作者：</strong>Wendy<br>
        <strong>本文链接：</strong><a href="https://wendy-ljw.github.io/2022/11/17/js-es6-1/" title="https:&#x2F;&#x2F;wendy-ljw.github.io&#x2F;2022&#x2F;11&#x2F;17&#x2F;js-es6-1&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;wendy-ljw.github.io&#x2F;2022&#x2F;11&#x2F;17&#x2F;js-es6-1&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/note/">note</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/es6/" rel="tag">es6</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/javascript/" rel="tag">javascript</a>
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="搜索" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script>

 

<script async src="/js/app.js?v=1668672300523"></script>



<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





</body>

</html>
