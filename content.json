{"meta":{"title":"Wendy","subtitle":"","description":"","author":"Wendy","url":"https://wendy-ljw.github.io","root":"/"},"pages":[{"title":"朋友","date":"2022-11-15T12:46:38.231Z","updated":"2022-11-15T12:46:38.231Z","comments":true,"path":"PY.html","permalink":"https://wendy-ljw.github.io/PY.html","excerpt":"","text":"戳这可见文特的博客"},{"title":"文章归档","date":"2022-11-10T11:15:45.811Z","updated":"2022-11-10T11:15:45.811Z","comments":true,"path":"archive.html","permalink":"https://wendy-ljw.github.io/archive.html","excerpt":"","text":""},{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2022-11-10T11:04:24.717Z","comments":true,"path":"page/index.html","permalink":"https://wendy-ljw.github.io/page/index.html","excerpt":"","text":"This is a page test."},{"title":"关于","date":"2022-11-15T12:46:33.299Z","updated":"2022-11-15T12:46:33.299Z","comments":true,"path":"about.html","permalink":"https://wendy-ljw.github.io/about.html","excerpt":"","text":"今天我终于把我的博客搭建成功了"}],"posts":[{"title":"js高级-es6笔记","slug":"js-es6-1","date":"2022-11-17T02:35:20.000Z","updated":"2022-11-17T07:53:33.983Z","comments":true,"path":"2022/11/17/js-es6-1/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/17/js-es6-1/","excerpt":"","text":"JavaScript 进阶 - 第1天 学习作用域、变量提升、闭包等语言特征，加深对 JavaScript 的理解，掌握变量赋值、函数声明的简洁语法，降低代码的冗余度。 理解作用域对程序执行的影响 能够分析程序执行的作用域范围 理解闭包本质，利用闭包创建隔离作用域 了解什么变量提升及函数提升 掌握箭头函数、解析剩余参数等简洁语法 一、作用域 了解作用域对程序执行的影响及作用域链的查找机制，使用闭包函数创建隔离作用域避免全局变量污染。 作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问，作用域分为全局作用域和局部作用域。 1.1 局部作用域局部作用域分为函数作用域和块作用域。 函数作用域在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。 &lt;script&gt; // 声明 counter 函数 function counter(x, y) &#123; // 函数内部声明的变量 const s = x + y console.log(s) // 18 &#125; // 设用 counter 函数 counter(10, 8) // 访问变量 s console.log(s)// 报错&lt;/script&gt; 总结： 函数内部声明的变量，在函数外部无法被访问 函数的参数也是函数内部的局部变量 不同函数内部声明的变量无法互相访问 函数执行完毕后，函数内部的变量实际被清空了 块作用域在 JavaScript 中使用 &#123;&#125; 包裹的代码称为代码块，代码块内部声明的变量外部将有可能无法被访问。 &lt;script&gt; &#123; // age 只能在该代码块中被访问 let age = 18; console.log(age); // 正常 &#125; // 超出了 age 的作用域 console.log(age) // 报错 let flag = true; if(flag) &#123; // str 只能在该代码块中被访问 let str = &#x27;hello world!&#x27; console.log(str); // 正常 &#125; // 超出了 str 的作用域 console.log(str); // 报错 for(let t = 1; t &lt;= 6; t++) &#123; // t 只能在该代码块中被访问 console.log(t); // 正常 &#125; // 超出了 t 的作用域 console.log(t); // 报错&lt;/script&gt; JavaScript 中除了变量外还有常量，常量与变量本质的区别是常量必须要有值且不允许被重新赋值，常量值为对象时其属性和方法允许重新赋值。 &lt;script&gt; // 必须要有值 const version = &#x27;1.0.0&#x27;; // 不能重新赋值 // version = &#x27;1.0.1&#x27;; // 常量值为对象类型 const user = &#123; name: &#x27;小明&#x27;, age: 18 &#125; // 不能重新赋值 user = &#123;&#125;; // 属性和方法允许被修改 user.name = &#x27;小小明&#x27;; user.gender = &#x27;男&#x27;;&lt;/script&gt; 总结： let 声明的变量会产生块作用域，var 不会产生块作用域 const 声明的常量也会产生块作用域 不同代码块之间的变量无法互相访问 推荐使用 let 或 const 注：开发中 let 和 const 经常不加区分的使用，如果担心某个值会不小被修改时，则只能使用 const 声明成常量。 1.2 全局作用域&lt;script&gt; 标签和 .js 文件的最外层就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。 &lt;script&gt; // 此处是全局 function sayHi() &#123; // 此处为局部 &#125; // 此处为全局&lt;/script&gt; 全局作用域中声明的变量，任何其它作用域都可以被访问，如下代码所示： &lt;script&gt; // 全局变量 name const name = &#x27;小明&#x27; // 函数作用域中访问全局 function sayHi() &#123; // 此处为局部 console.log(&#x27;你好&#x27; + name) &#125; // 全局变量 flag 和 x const flag = true let x = 10 // 块作用域中访问全局 if(flag) &#123; let y = 5 console.log(x + y) // x 是全局的 &#125;&lt;/script&gt; 总结： 为 window 对象动态添加的属性默认也是全局的，不推荐！ 函数中未使用任何关键字声明的变量为全局变量，不推荐！！！ 尽可能少的声明全局变量，防止全局变量被污染 JavaScript 中的作用域是程序被执行时的底层机制，了解这一机制有助于规范代码书写习惯，避免因作用域导致的语法错误。 1.3 作用域链在解释什么是作用域链前先来看一段代码： &lt;script&gt; // 全局作用域 let a = 1 let b = 2 // 局部作用域 function f() &#123; let c // 局部作用域 function g() &#123; let d = &#x27;yo&#x27; &#125; &#125;&lt;/script&gt; 函数内部允许创建新的函数，f 函数内部创建的新函数 g，会产生新的函数作用域，由此可知作用域产生了嵌套的关系。 如下图所示，父子关系的作用域关联在一起形成了链状的结构，作用域链的名字也由此而来。 作用域链本质上是底层的变量查找机制，在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域，如下代码所示： &lt;script&gt; // 全局作用域 let a = 1 let b = 2 // 局部作用域 function f() &#123; let c // let a = 10; console.log(a) // 1 或 10 console.log(d) // 报错 // 局部作用域 function g() &#123; let d = &#x27;yo&#x27; // let b = 20; console.log(b) // 2 或 20 &#125; // 调用 g 函数 g() &#125; console.log(c) // 报错 console.log(d) // 报错 f();&lt;/script&gt; 总结： 嵌套关系的作用域串联起来形成了作用域链 相同作用域链中按着从小到大的规则查找变量 子作用域能够访问父作用域，父级作用域无法访问子级作用域 1.4 垃圾回收机制1.4.1 什么是垃圾回收机制？垃圾回收机制（Garbage Collection) 简称 GCJS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收 1.4.2 内存泄漏正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法回收）的情况不再用到的内存，没有及时释放，就叫做内存泄漏 1.4.3 内存的生命周期JS环境中分配的内存，一般有如下生命周期： 内存分配： 当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 内存使用： 即读写内存，也就是使用变量、函数等 内存回收： 使用完毕，由垃圾回收自动回收不再使用的内容 说明： 全局变量一般不会回收（关闭页面回收）； 一般情况下局部变量的值，不用了会被自动回收掉 1.4.4 垃圾回收算法说明所谓垃圾回收，核心思想就是如何判断内存是否已经不再会被使用了，如果是，就视为垃圾，释放掉有两种常见的浏览器垃圾回收算法： 引用计数法和标记清除法 引用计数IE采用的引用计数算法，定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。算法： 跟踪记录每个值被引用的次数。 如果这个值的被引用了一次，那么就记录次数加1 多次引用会累加 如果减少一个引用就减1 如果引用次数是0，则释放内存&lt;script&gt; const person=&#123; //定义了person，引用次数为1 age:18, name:&#x27;ljw&#x27; &#125; const p=person //因为引用的是地址，所以引用次数加一 person=1 //person不再指向原来的结构体，所以引用次数减一 p=null //p也不再指向原来的结构体，所以引用次数减一 //此时引用次数为0，释放内存&lt;/script&gt; 由上面可以看出，引用计数算法是个简单有效的算法。但它却存在一个致命的问题：嵌套引用如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄漏。 &lt;script&gt; function fn()&#123; let o1 = &#123;&#125; let o2 = &#123;&#125; o1.a = o2 o2.a = o1 return &#x27;引用计数无法回收&#x27; &#125; fn()&lt;/script&gt; 因为他们的引用次数永远不会是0，这样的相互引用如果很大量的存在就会导致大量的内存泄漏 标记清除法 现在的浏览器已经不再使用引用计数算法了。现在浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。核心： 标记清除算法将“不再使用的对象”定义为“无法达到的对象” 就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收 1.5 闭包闭包（closure）是一种比较特殊和函数，使用闭包能够访问函数作用域中的变量。一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域 闭包&#x3D;内层函数+外层函数的变量 从代码形式上看闭包是一个做为返回值的函数，如下代码所示： &lt;script&gt; function foo() &#123; let i = 0; // 函数内部分函数 function bar() &#123; console.log(++i); &#125; // 将函数做为返回值 return bar; &#125; // fn 即为闭包函数 let fn = foo(); fn(); // 1&lt;/script&gt; 常见闭包的形式：外部可以访问使用函数内部的变量 总结： 闭包本质仍是函数，只不是从函数内部返回的 闭包能够创建外部可访问的隔离作用域，避免全局变量污染 过度使用闭包可能造成内存泄漏 注：回调函数也能访问函数内部的局部变量。 1.6 变量提升变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问。 把所有var声明的变量提升到当前作用域的最前面，只提升声明，不提升赋值 &lt;script&gt; // 访问变量 str console.log(str + &#x27;world!&#x27;); // 声明变量 str var str = &#x27;hello &#x27;;&lt;/script&gt; 总结： 变量在未声明即被访问时会报语法错误 变量在声明之前即被访问，变量的值为 undefined let 声明的变量不存在变量提升，推荐使用 let 变量提升出现在相同作用域当中 实际开发中推荐先声明再访问变量 注：关于变量提升的原理分析会涉及较为复杂的词法分析等知识，而开发中使用 let 可以轻松规避变量的提升，因此在此不做过多的探讨，有兴趣可查阅资料。 二、函数 知道函数参数默认值、动态参数、剩余参数的使用细节，提升函数应用的灵活度，知道箭头函数的语法及与普通函数的差异。 2.1 函数提升函数提升与变量提升比较类似，是指函数在声明之前即可被调用。 会把所有函数声明提升到当前作用域的最前面只提升函数声明，不提升函数调用 &lt;script&gt; // 调用函数 foo() // 声明函数 function foo() &#123; console.log(&#x27;声明之前即被调用...&#x27;) &#125; // 不存在提升现象 bar() // 错误 var bar = function () &#123; //因为变量被提升了，但是函数赋值没有被提升 console.log(&#x27;函数表达式不存在提升现象...&#x27;) &#125;&lt;/script&gt; 总结： 函数提升能够使函数的声明调用更灵活 函数表达式不存在提升的现象 函数提升出现在相同作用域当中 2.2 参数函数参数的使用细节，能够提升函数应用的灵活度。 默认值&lt;script&gt; // 设置参数默认值 function sayHi(name=&quot;小明&quot;, age=18) &#123; document.write(`&lt;p&gt;大家好，我叫$&#123;name&#125;，我今年$&#123;age&#125;岁了。&lt;/p&gt;`); &#125; // 调用函数 sayHi(); sayHi(&#x27;小红&#x27;); sayHi(&#x27;小刚&#x27;, 21);&lt;/script&gt; 总结： 声明函数时为形参赋值即为参数的默认值 如果参数未自定义默认值时，参数的默认值为 undefined 调用函数时没有传入对应实参时，参数的默认值被当做实参传入 动态参数arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参。 &lt;script&gt; // 求生函数，计算所有参数的和 function sum() &#123; // console.log(arguments) let s = 0 for(let i = 0; i &lt; arguments.length; i++) &#123; s += arguments[i] &#125; console.log(s) &#125; // 调用求和函数 sum(5, 10)// 两个参数 sum(1, 2, 4) // 两个参数&lt;/script&gt; 总结： arguments 是一个伪数组 arguments 的作用是动态获取函数的实参 剩余参数&lt;script&gt; function config(baseURL, ...other) &#123; console.log(baseURL) // 得到 &#x27;http://baidu.com&#x27; console.log(other) // other 得到 [&#x27;get&#x27;, &#x27;json&#x27;] &#125; // 调用函数 config(&#x27;http://baidu.com&#x27;, &#x27;get&#x27;, &#x27;json&#x27;);&lt;/script&gt; 总结： ... 是语法符号，置于最末函数形参之前，用于获取多余的实参 借助 ... 获取的剩余实参，是个真数组 展开运算符展开运算符（…），将一个数组进行展开 const arr = [1,2,3,4,5]console.log(...arr) // 1 2 3 4 5 不会改变原数组 典型运用场景：求数组最大值（最小值）、合并数组等 //求最值console.log(Math.max(...arr))console.log(Math.min(...arr))//合并数组const arr2 = [3,4,5]const arr = [...arr1,...arr2] 展开运算符的剩余参数的区别：剩余参数：函数参数使用，得到真数组展开运算符：数组中使用，数组展开 2.3 箭头函数箭头函数是一种声明函数的简洁语法，它与普通函数并无本质的区别，差异性更多体现在语法格式上。 引入箭头函数的目的是更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁箭头函数更适用于那些本来需要匿名函数的地方 &lt;script&gt; // 箭头函数 const foo = () =&gt; &#123; //本行相当于 const foo = function () &#123; console.log(&#x27;^_^ 长相奇怪的函数...&#x27;); &#125; // 调用函数 foo() //只有一个参数时可以省略圆括号 () const fn = a =&gt; &#123; console.log(a) &#125; //函数体只有一行代码时可以省略花括号 `&#123;&#125;`，并自动做为返回值被返回 const fn = a =&gt; a + a // 更简洁的语法 const form = document.querySelector(&#x27;form&#x27;) form.addEventListener(&#x27;click&#x27;, ev =&gt; ev.preventDefault()) //可以直接返回一个对象 const fn = (uname) =&gt; (&#123; uname: uname &#125;)&lt;/script&gt; 箭头函数中的this // 以前this的指向： 谁调用的这个函数，this 就指向谁 console.log(this) // window // 普通函数 function fn() &#123; console.log(this) // window &#125; window.fn() // 对象方法里面的this const obj = &#123; name: &#x27;andy&#x27;, sayHi: function () &#123; console.log(this) // obj &#125; &#125; obj.sayHi()// 2. 箭头函数的this 是上一层作用域的this 指向 const fn = () =&gt; &#123; console.log(this) // window &#125; fn()// 对象方法箭头函数 this const obj = &#123; uname: &#x27;pink老师&#x27;, sayHi: () =&gt; &#123; console.log(this) // this 指向谁？ window &#125; &#125; obj.sayHi()const obj = &#123; uname: &#x27;pink老师&#x27;, sayHi: function () &#123; console.log(this) // obj let i = 10 const count = () =&gt; &#123; console.log(this) // obj &#125; count() &#125;&#125;obj.sayHi() 总结： 箭头函数属于表达式函数，因此不存在函数提升 箭头函数只有一个参数时可以省略圆括号 () 箭头函数函数体只有一行代码时可以省略花括号 &#123;&#125;，并自动做为返回值被返回 箭头函数中没有 arguments，只能使用剩余函数 ... 动态获取实参 箭头函数不会创建自己的this,它只会从自己的作用域链的上一层延用this DOM事件回调函数不推荐使用箭头函数，特别是要用到this的时候 事件回调函数使用箭头函数时，this为全局的window 三、解构赋值 知道解构的语法及分类，使用解构简洁语法快速为变量赋值。 解构赋值是一种快速为变量赋值的简洁语法，本质上仍然是为变量赋值，分为数组解构、对象解构两大类型。 3.1 数组解构数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法，如下代码所示： &lt;script&gt; // 普通的数组 let arr = [1, 2, 3]; // 批量声明变量 a b c // 同时将数组单元值 1 2 3 依次赋值给变量 a b c let [a, b, c] = arr; console.log(a); // 1 console.log(b); // 2 console.log(c); // 3&lt;/script&gt; 总结： 赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量 变量的顺序对应数组单元值的位置依次进行赋值操作 变量的数量大于单元值数量时，多余的变量将被赋值为 undefined 变量的数量小于单元值数量时，可以通过 ... 获取剩余单元值，但只能置于最末位 允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效 注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析 3.2 对象解构对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法，如下代码所示： &lt;script&gt; // 普通对象 const user = &#123; name: &#x27;小明&#x27;, age: 18 &#125;; // 批量声明变量 name age // 同时将数组单元值 小明 18 依次赋值给变量 name age const &#123;name, age&#125; = user console.log(name) // 小明 console.log(age) // 18&lt;/script&gt; 总结： 赋值运算符 = 左侧的 &#123;&#125; 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量 对象属性的值将被赋值给与属性名相同的变量 对象中找不到与变量名一致的属性时变量值为 undefined 允许初始化变量的默认值，属性不存在或单元值为 undefined 时默认值才会生效 注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析","categories":[{"name":"note","slug":"note","permalink":"https://wendy-ljw.github.io/categories/note/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://wendy-ljw.github.io/tags/es6/"}]},{"title":"git学习笔记","slug":"git-note","date":"2022-11-15T09:27:28.000Z","updated":"2022-11-16T13:55:43.696Z","comments":true,"path":"2022/11/15/git-note/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/15/git-note/","excerpt":"","text":"Git实战听故事顺便学git，可能是全世界最好玩的git教程。 第一章 快速入门1.1 什么是GitGit是一个分布式的版本控制软件。 软件，类似于QQ、office、dota等安装到电脑上才能使用的工具。 版本控制，类似于毕业论文、写文案、视频剪辑等，需要反复修改和保留原历史数据。 分布式 文件夹拷贝 本地版本控制 集中式版本控制 分布式版本控制 1.2 为什么要做版本控制要保留之前所有的版本，以便回滚和修改。 1.3 安装git详见：https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git 1.4 git三大区域 工作区（红色区域） 已管理文件中的新增文件或修改文件（自动检测） 目的：方便写代码，方便修改，把改变的部分放这 暂存区（绿色区域） 把工作区里的文件用git add提交到暂存区 目的：起到一个缓冲的作用，是工作区与版本库的过度区域 版本库 把暂存区里的文件用git commit提交到版本库 目的：最终的每一个版本都放在这 第二章 “东北热”创业史2.1 第一阶段：单枪匹马开始干想要让git对一个目录进行版本控制需要以下步骤： 进入要管理的文件夹 执行初始化命令 git init 管理目录下的文件状态 git status注：新增的文件和修改过后的文件都是红色 管理指定文件（红变绿） git add 文件名git add . 个人信息配置：用户名、邮箱 【一次即可】 git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 生成版本 git commit -m &#x27;描述信息&#x27; //单引号中主要放对版本的描述信息，如初稿，版本号等 查看版本记录 git log 2.2 第二阶段：拓展新功能git add git commit -m &#x27;短视频&#x27; 新增了有短视频功能的版本 2.3 第三阶段：“约饭事件” 回滚至之前版本 git log git reset --hard 版本号 版本号指的是git log执行后输出的commit后面的一大串字母数字 回滚至之后版本 git reflog git reset --hard 版本号 这里的版本号是git reflog执行后输出的每一行最前面的一小串字母数字 2.4 小总结git init git add git commit git log git reflog git reset --hard 版本号 2.5 第四阶段：商城&amp;紧急修复bug2.5.1 分支分支可以给使用者提供多个环境的可以，意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 2.5.2 紧急修复bug方案 2.5.3 命令总结 查看分支 git branch 创建分支 git branch 分支名称 切换分支 git checkout 分支名称 分支合并（可能产生冲突） git merge 要合并的分支注意：切换分支再合并 删除分支 git branch -d 分支名称 2.5.4 工作流 2.6 第五阶段：进军三里屯有钱之后就要造呀，一个人在三里屯买了一层楼做办公室。 2.6.1 第一天上班前在家上传代码首先，需要注册github账号，并创建远程仓库，然后再执行如下命令，将代码上传到github。 1. 给远程仓库起别名 git remote add origin 远程仓库地址2. 向远程推送代码 git push -u origin 分支 2.6.2 初次在公司新电脑下载代码1. 克隆远程仓库代码 git clone 远程仓库地址 (内部已实现git remote add origin 远程仓库地址)2. 切换分支 git checkout 分支 在公司下载完代码后，继续开发 1. 切换到dev分支进行开发 git checkout dev 2. 把master分支合并到dev [仅一次] git merge master3. 修改代码4. 提交代码 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.3 下班回到家继续写代码1. 切换到dev分支进行开发 git checkout dev 2. 拉代码 git pull origin dev 3. 继续开发4. 提交代码 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.4 到公司继续开发1. 切换到dev分支进行开发 git checkout dev 2. 拉最新代码(不必再clone，只需要通过pull获取最新代码即可) git pull origin dev 3. 继续开发4. 提交代码 git add . git commit -m &#x27;xx&#x27; git push origin dev 开发完毕，要上线 1. 将dev分支合并到master，进行上线 git checkout master git merge dev git push origin master2. 把dev分支也推送到远程 git checkout dev git merge master git push origin dev 2.6.5 在公司约妹子忘记提交代码1. 拉代码 git pull origin dev 2. 继续开发3. 提交代码 git add . git commit -m &#x27;xx&#x27;注：忘记push了 2.6.6 回家继续写代码1. 拉代码，发现在公司写的代码忘记提交... git pull origin dev 2. 继续开发其他功能 3. 把dev分支也推送到远程 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.7 到公司继续写代码1. 拉代码，把晚上在家写的代码拉到本地(有合并、可能产生冲突) git pull origin dev 2. 如果有冲突，手动解决冲突 3. 继续开发其他功能 4. 把dev分支也推送到远程 git add . git commit -m &#x27;xx&#x27; git push origin dev 2.6.8 其他git pull origin dev等价于git fetch origin devgit merge origin/dev 2.6.9 rebase的作用？rebase可以保持提交记录简洁，不分叉。 2.6.9 快速解决冲突 安装beyond compare 在git中配置 git config --local merge.tool bc3git config --local mergetool.path &#x27;/usr/local/bin/bcomp&#x27;git config --local mergetool.keepBackup false 应用beyond compare 解决冲突 git mergetool 2.7 小总结 添加远程连接（别名） git remote add origin 地址 推送代码 git push origin dev 下载代码 git clone 地址 拉取代码 git pull origin dev 等价于git fetch origin devgit merge origin/dev 保持代码提交整洁（变基） git rebase 分支 记录图形展示 git log --graph --pretty=format:&quot;%h %s&quot; 2.8 第六阶段：多人协同开发工作流 2.8.1 创建项目&amp;邀请成员协同开发时，需要所有成员都可以对同一个项目进行操作，需要邀请成员并赋予权限，否则无法开发。github支持两种创建项目的方式（供多人协同开发）。 合作者，将用户添加到仓库合作者中之后，该用户就可以向当前仓库提交代码。 组织，将成员邀请进入组织，组织下可以创建多个仓库，组织成员可以向组织下仓库提交代码。 扩展：Tag标签管理为了能清晰的管理版本，在公司不会直接使用commit来做版本，会基于Tag来实现：v1.0 、 v1.2 、v2.0 版本。 git tag -a v1.0 -m &#x27;版本介绍&#x27; 创建本地创建Tag信息git tag -d v1.0 删除Taggit push origin --tags 将本地tag信息推送到远程仓库git pull origin --tags 更新本地tag版本信息git checkout v.10 切换taggit clone -b v0.1 地址 指定tag下载代码 2.8.2 小弟开发 小弟注册Github 或 Gitlab账号 邀请小弟进入组织（默认对组织中的项目具有读权限） 邀请小弟成为某项目的合作者 小弟在自己电脑上下载代码并开发 git clone https://github.com/oldboy-org/dbhot.gitcd dbhotgit checkout devgit checkout -b dzz 写代码...git add .git commit -m &#x27;斗地主功能开发完成&#x27;git push origin ddz 2.8.3 code review 配置，代码review之后才能合并到dev分支。 小弟提交 code review申请 组长做 code review 2.8.4 提测上线（预发布）由专门团队或团队leader执行以下步骤： 基于dev分值创建release分值 git checkout devgit checkout -b release 测试等 合并到master 使用pull request或本地将release合并到master分支 在master分支打tag git tag -a v2 -m &#x27;第二版 斗地主功能&#x27;git push origin --tags 运维人员就可以去下载代码做上线了 git clone -b v2 地址 2.9 第七阶段：给开源软件贡献代码 fork源代码将别人源代码拷贝到我自己的远程仓库。 在自己仓库进行修改代码 给源代码的作者提交 修复bug的申请（pull request） 第三章 其他3.1 配置 项目配置文件：项目&#x2F;.git&#x2F;config git config --local user.name &#x27;武沛齐&#x27;git config --local user.email &#x27;wupeiqi@xx.com&#x27; 全局配置文件: ~&#x2F;.gitconfig git config --global user.name &#x27;wupeiq&#x27;git config --global user.name &#x27;wupeiqi@xx.com&#x27; 系统配置文件：&#x2F;etc&#x2F;.gitconfig git config --system user.name &#x27;wupeiq&#x27;git config --system user.name &#x27;wupeiqi@xx.com&#x27;注意：需要有root权限 应用场景： git config --local user.name &#x27;武沛齐&#x27;git config --local user.email &#x27;wupeiqi@xx.com&#x27;git config --local merge.tool bc3git config --local mergetool.path &#x27;/usr/local/bin/bcomp&#x27;git config --local mergetool.keepBackup falsegit remote add origin 地址 ，默认添加在本地配置文件中(--local) 3.2 免密码登录 URL中体现 原来的地址：https://github.com/WuPeiqi/dbhot.git修改的地址：https://用户名:密码@github.com/WuPeiqi/dbhot.gitgit remote add origin https://用户名:密码@github.com/WuPeiqi/dbhot.gitgit push origin master SSH实现 1. 生成公钥和私钥(默认放在 ~/.ssh目录下，id_rsa.pub公钥、id_rsa私钥） ssh-keygen2. 拷贝公钥的内容，并设置到github中。3. 在git本地中配置ssh地址 git remote add origin git@github.com:WuPeiqi/dbhot.git 4. 以后使用 git push origin master git自动管理凭证 3.3 git忽略文件让Git不再管理当前目录下的某些文件。 *.h!a.hfiles/*.py[c|a|d] 更多参考：https://github.com/github/gitignore 3.4 github任务管理相关 issues，文档以及任务管理。 wiki，项目文档。 结课感谢各位同学的关注和学习，希望git实战课程对你能够有所帮助，更多资源关注： 小猿圈 &lt;www.apeland.cn&gt; 路飞学城 &lt;www.luffycity.com&gt; 老男孩IT教育 &lt;www.oldboyedu.com&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","permalink":"https://wendy-ljw.github.io/tags/git/"}]},{"title":"原型与原型链","slug":"js-prototype","date":"2022-11-14T09:44:36.000Z","updated":"2022-11-15T12:44:39.251Z","comments":true,"path":"2022/11/14/js-prototype/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/14/js-prototype/","excerpt":"","text":"原型与原型链原型：被用于复制现有实例来生成新实例的函数 原型链：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。 构造函数：用new来调用，就是为了创建一个自定义类，构造函数和普通函数本质上没什么区别，只不过使用了new关键字创建对象的函数，被叫做了构造函数。 实例：是类在实例化之后一个一个具体的对象 原型JS中每一个函数都有一个prototype属性，这个属性指向函数的原型对象，每一个由原型对象派生的子对象，都有相同的属性。子对象就叫构造函数，从实例原型中获取相同的属性。 我们所创建的每一格函数，解析器都会向函数中添加一个属性prototype这个属性对应着一个对象，这个对象就是我们所谓的原型对象 打比方说： function Person(age) &#123; this.age = age &#125;Person.prototype.name = &#x27;ljw&#x27;var person1 = new Person()var person2 = new Person()console.log(person1.name) //ljwconsole.log(person2.name) //ljw 其中，函数的prototype指向了一个对象，而这个对象正是调用构造函数时创建的实例的原型，也就是person1和person2的原型。 _Proto __Proto _是每一个子对象（除null外）都会有的一个属性，指向该对象的原型 当函数以构造函数的形式调用时，它所创造的对象中都会有一个隐含的属性指向该构造函数的原型对象，我们可以通过_proto_来访问属性 function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 此属性可以访问原型，但并不存在于Person.prototype中，来自于Object.prototype,类似getter&#x2F;setter，即使用obj._proto_时，可以理解为返回Object.getPrototypeOf(obj) 构造函数constructor每个原型都有一个constructor属性，指向该关联的构造函数 如果函数作为普通函数调用prototype没有任何作用 function Person() &#123;&#125;console.log(Person===Person.prototype.constructor) //true function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层(也就是Object)为止。 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中 function Person() &#123;&#125;Person.prototype.name = &#x27;Kevin&#x27;;var person = new Person();person.name = &#x27;Daisy&#x27;;console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.proto ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 原型链原型对象也是对象，所以它也有原型，当我们使用一个对象的属性或方法时，会按照以下步骤： 先在自身中寻找 自身中如果有，则直接使用 如果自身中没有则去原型对象中寻找，如果原型对象中有，则使用 如果原型对象中没有，则去原型对象的原型对象中寻找，直到找到Object对象的原型 Object有原型，但Object的原型没有原型，如果在Object的原型里没有找到，则返回undefined 整个查找过程都是顺着__proto__属性，一步一步往上查找，形成了像链条一样的结构，这个结构，就是原型链。所以，原型链也叫作隐式原型链。 检查属性函数 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回trueconsole.log(&quot;name&quot; in person) //true 使用对象的hasOwnProperty()来检查对象自身中是否含有该属性，只有当对象自身中含有属性时，才会返回trueconsole.log(&quot;person.hasOwnProperty()&quot;) //false","categories":[{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"}]},{"title":"Markdown使用指南","slug":"markdown","date":"2022-11-11T01:12:03.000Z","updated":"2022-11-15T12:44:59.085Z","comments":true,"path":"2022/11/11/markdown/","link":"","permalink":"https://wendy-ljw.github.io/2022/11/11/markdown/","excerpt":"我的第一篇博客，从刚学来的markdown开始","text":"我的第一篇博客，从刚学来的markdown开始 标题1.分级标题&#x3D;&#x3D;&#x3D;&#x3D;上面一行的内容就是一级标题—-上面一行的内容就是二级标题&#x3D;&#x3D;&#x3D;&#x3D;或—-都要单独一行 这是一个一级标题============================这是一个二级标题---------------------------- 第二种写法用#放标题最前面，几个#表示是几级标题 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 2.斜体和粗体代码 *斜体*或_斜体_**粗体*****加粗斜体***~~删除线~~ 显示效果 这是一段斜体 这是一段粗体 这是一段加粗斜体 这是一段删除线 3.超链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 3.1 行内式 [链接名](链接地址 “链接的title属性”)链接的title属性可以不加 欢迎来到[重庆理工大学](https://www.cqut.edu.cn/)欢迎来到[重庆理工大学](https://www.cqut.edu.cn/ &quot;重庆理工大学&quot;) 显示效果 欢迎来到重庆理工大学 欢迎来到重庆理工大学 3.2 参考式 利用变量的形式&#x2F;[链接名][链接变量名] 一般用在学术论文上 当某个链接在文章中多处使用的时候，也可以使用参考式超链接，会很方便 比如说[CQUT][1]、[Google][g][1]:https://www.cqut.edu.cn &quot;CQUT&quot;[g]:http://www.google.com &quot;Google&quot; 显示效果 比如说CQUT、Google 3.3 自动连接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。 &lt;https://www.cqut.edu.cn/&gt; 显示效果 https://www.cqut.edu.cn/ 4.列表4.1 无序列表使用 *，+，- 表示无序列表。 - 哈哈- 嘿嘿- 嘻嘻 显示效果 哈哈 嘿嘿 嘻嘻 4.2 有序列表有序列表则使用数字接着一个英文句点。 1. 嘿嘿2. 哈哈3. 嘻嘻 显示效果 嘿嘿 哈哈 嘻嘻 4.3 列表缩进- 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！- 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 4.4 包含段落的列表* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ * 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 4.5 列表嵌套* 无序1 1. 有序1 2. 有序2 - 无序3 3. 有序3* 无序2 - 无序4 显示效果 无序1 有序1 有序2 无序3 有序3 无序2 无序4 5.区块引用&gt;这是一个区块引用 显示效果 这是一个区块引用 还可嵌套引用 5.1 嵌套列表&gt;- 嵌套无序列表&gt;- haha&gt;1. 嵌套有序列表&gt;2.xixi 显示效果 嵌套无序列表 haha 嵌套有序列表 xixi 5.2 嵌套代码&gt;代码&gt;&gt; return 0; 显示效果 代码 return 0; 6.图像与超链接用法相似 6.1 行内式![花花](http://xtzl.wentexl.cn/ljw/bjt/b0002.jpg) 显示效果 6.2 参考式![花花][f][f]:http://xtzl.wentexl.cn/ljw/bjt/b0002.jpg &quot;花花&quot; 显示效果 7.注脚在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。[^1]:Markdown是一种纯文本标记语言[^2]:HyperTextMarkupLanguage超文本标记语言[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文 显示效果 使用 Markdown^1可以效率的书写文档, 直接转换成 HTML^2, 你可以使用 Leanote^Le 编辑器进行书写。 8.引用公式$表示行内公式 $$表示整行公式 一元二次方程$y=ax^2+bx+c$ 显示效果 一元二次方程$y&#x3D;ax^2+bx+c$ $$y=ax^2+bx+c$$$$x=x+1$$ 显示效果$$y&#x3D;ax^2+bx+c$$$$x&#x3D;x+1$$ 9.表格 不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。普通格式|表头|表头||-|-||1|单元格||2|表格|简单格式|表头|表头|-|-|1|单元格||2|表格|对齐|左对齐|右对齐|居中对齐|:-|-:|:-:|1|单元格|表格||2|表格|单元格| 显示效果 普通格式 表头 表头 1 单元格 2 表格 简单格式 表头 表头 1 单元格 2 表格 对齐 左对齐 右对齐 居中对齐 1 单元格 表格 2 表格 单元格 10.分隔线用三个及以上的*-_以及空格组成，显示效果都一样 **** * ******- - ----------- 显示效果 11.代码对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”&#96;”符号（一般在ESC键下方）包裹代码。 11.1 行内式记得`return 0` 显示效果 记得return 0 11.2 多行代码利用缩进或者是用&#96;&#96;&#96;&#96;&#96;&#96;包裹代码 #include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;Hello world\\n&quot;);&#125; 显示效果 #include &lt;stdio.h&gt; int main(void) &#123; printf(&quot;Hello world\\n&quot;); &#125; 11.3 直接引用HTML&lt;div&gt;这是一个块&lt;/div&gt; 显示效果 这是一个块 11.4 转义引用可以用反斜杠打印特殊符号，如： \\ 反斜线` 反引号* 星号_ 下划线&#123;&#125; 花括号[] 方括号() 小括号# 井字号+ 加号- 减号. 英文句点! 感叹号","categories":[{"name":"总结","slug":"总结","permalink":"https://wendy-ljw.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://wendy-ljw.github.io/tags/markdown/"}]},{"title":"文章演示页面","slug":"post-example","date":"2021-07-24T16:00:00.000Z","updated":"2022-11-15T12:46:09.348Z","comments":true,"path":"2021/07/25/post-example/","link":"","permalink":"https://wendy-ljw.github.io/2021/07/25/post-example/","excerpt":"显示在首页的内容","text":"显示在首页的内容 一级标题二级标题三级标题四级标题瀑布流图片 相片集 字符效果和横线等 删除线斜体字 斜体字粗体 粗体粗斜体 粗斜体 上标：X2，下标：O2 缩写(同HTML的abbr标签) 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启 The HTML specification is maintained by the W3C. 引用 Blockquotes 引用文本 Blockquotes 锚点与链接 Links普通链接 普通链接带描述 直接链接：https://github.com 多语言代码高亮 Codes行内代码 Inline code执行命令：npm install marked JS代码function test()&#123; console.log(&quot;Hello world!&quot;);&#125; (function()&#123; var box = function()&#123; return box.fn.init(); &#125;; box.prototype = box.fn = &#123; init : function()&#123; console.log(&#x27;box.init()&#x27;); return this; &#125;, add : function(str)&#123; alert(&quot;add&quot;, str); return this; &#125;, remove : function(str)&#123; alert(&quot;remove&quot;, str); return this; &#125; &#125;; box.fn.init.prototype = box.fn; window.box =box;&#125;)();var testBox = box();testBox.add(&quot;jQuery&quot;).remove(&quot;jQuery&quot;); HTML代码 HTML codes&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest=&quot;utf-8&quot; /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello world!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 图片 Images 图片加链接 (Image + Link)： 列表 Lists无序列表 列表一 列表二 列表二-1 列表二-2 列表二-3 列表三 列表一 列表二 列表三 有序列表 第一行 第二行 第三行 GFM task list GFM task list 1 GFM task list 2 GFM task list 3 GFM task list 3-1 GFM task list 3-2 GFM task list 3-3 GFM task list 4 GFM task list 4-1 GFM task list 4-2 绘制表格 Tables 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234","categories":[{"name":"种类","slug":"种类","permalink":"https://wendy-ljw.github.io/categories/%E7%A7%8D%E7%B1%BB/"}],"tags":[{"name":"标签","slug":"标签","permalink":"https://wendy-ljw.github.io/tags/%E6%A0%87%E7%AD%BE/"}]}],"categories":[{"name":"note","slug":"note","permalink":"https://wendy-ljw.github.io/categories/note/"},{"name":"笔记","slug":"笔记","permalink":"https://wendy-ljw.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"总结","slug":"总结","permalink":"https://wendy-ljw.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"种类","slug":"种类","permalink":"https://wendy-ljw.github.io/categories/%E7%A7%8D%E7%B1%BB/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wendy-ljw.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://wendy-ljw.github.io/tags/es6/"},{"name":"git","slug":"git","permalink":"https://wendy-ljw.github.io/tags/git/"},{"name":"markdown","slug":"markdown","permalink":"https://wendy-ljw.github.io/tags/markdown/"},{"name":"标签","slug":"标签","permalink":"https://wendy-ljw.github.io/tags/%E6%A0%87%E7%AD%BE/"}]}